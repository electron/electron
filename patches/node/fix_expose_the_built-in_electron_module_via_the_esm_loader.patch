From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samuel Attard <sattard@salesforce.com>
Date: Thu, 6 Oct 2022 04:09:16 -0700
Subject: fix: expose the built-in electron module via the ESM loader

This allows usage of `import { app } from 'electron'` and `import('electron')` natively in the browser + non-sandboxed renderer

diff --git a/lib/internal/modules/esm/get_format.js b/lib/internal/modules/esm/get_format.js
index 48ccb97a6244eab4bcfbee92feb9829ca32ad0c5..043d094540845228556b0f9837f48fbaddedfb47 100644
--- a/lib/internal/modules/esm/get_format.js
+++ b/lib/internal/modules/esm/get_format.js
@@ -26,6 +26,7 @@ const protocolHandlers = {
   'data:': getDataProtocolModuleFormat,
   'file:': getFileProtocolModuleFormat,
   'node:'() { return 'builtin'; },
+  'electron:'() { return 'electron'; },
 };
 
 /**
diff --git a/lib/internal/modules/esm/load.js b/lib/internal/modules/esm/load.js
index c284163fba86ec820af1996571fbd3d092d41d34..5f1921d15bc1d3a68c35990f85e36a0e8a5b3ec4 100644
--- a/lib/internal/modules/esm/load.js
+++ b/lib/internal/modules/esm/load.js
@@ -77,7 +77,7 @@ function defaultLoad(url, context = kEmptyObject) {
 
   throwIfUnsupportedURLScheme(urlInstance);
 
-  if (urlInstance.protocol === 'node:') {
+  if (urlInstance.protocol === 'node:' || format === 'electron') {
     source = null;
     format ??= 'builtin';
   } else if (format === 'addon') {
@@ -93,7 +93,7 @@ function defaultLoad(url, context = kEmptyObject) {
       // Now that we have the source for the module, run `defaultGetFormat` to detect its format.
       format = defaultGetFormat(urlInstance, context);
 
-      if (format === 'commonjs') {
+      if (format === 'electron' || format === 'commonjs') {
         // For backward compatibility reasons, we need to discard the source in
         // order for the CJS loader to re-fetch it.
         source = null;
@@ -142,7 +142,7 @@ function defaultLoadSync(url, context = kEmptyObject) {
   throwIfUnsupportedURLScheme(urlInstance, false);
 
   let shouldBeReloadedByCJSLoader = false;
-  if (urlInstance.protocol === 'node:') {
+  if (urlInstance.protocol === 'node:' || format === 'electron') {
     source = null;
     format ??= 'builtin';
   } else if (format === 'addon') {
@@ -186,12 +186,13 @@ function throwIfUnsupportedURLScheme(parsed) {
     protocol !== 'file:' &&
     protocol !== 'data:' &&
     protocol !== 'node:' &&
+    protocol !== 'electron:' &&
     (
       protocol !== 'https:' &&
       protocol !== 'http:'
     )
   ) {
-    const schemes = ['file', 'data', 'node'];
+    const schemes = ['file', 'data', 'node', 'electron'];
     throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed, schemes);
   }
 }
diff --git a/lib/internal/modules/esm/loader.js b/lib/internal/modules/esm/loader.js
index 22c1e9f1ae652b033903f56f394352806ddff754..961da666a233541203b5416909fd1ff0326e63e1 100644
--- a/lib/internal/modules/esm/loader.js
+++ b/lib/internal/modules/esm/loader.js
@@ -437,7 +437,7 @@ class ModuleLoader {
     assert(wrap instanceof ModuleWrap, `Translator used for require(${url}) should not be async`);
 
     const cjsModule = wrap[imported_cjs_symbol];
-    if (cjsModule) {
+    if (cjsModule && translatorKey !== 'electron') {
       // Check if the ESM initiating import CJS is being required by the same CJS module.
       if (cjsModule?.[kIsExecuting]) {
         const parentFilename = urlToFilename(parentURL);
diff --git a/lib/internal/modules/esm/resolve.js b/lib/internal/modules/esm/resolve.js
index c1d774b9c5c4049f7ecda4e3a1faaa59dad01764..4fd58b1cea557ec122bd860e1ebc15bd04c44f78 100644
--- a/lib/internal/modules/esm/resolve.js
+++ b/lib/internal/modules/esm/resolve.js
@@ -752,6 +752,9 @@ function packageImportsResolve(name, base, conditions) {
   throw importNotDefined(name, packageJSONUrl, base);
 }
 
+const electronTypes = [
+  'electron', 'electron/main', 'electron/common', 'electron/renderer', 'electron/utility'
+];
 
 /**
  * Resolves a package specifier to a URL.
@@ -766,6 +769,11 @@ function packageResolve(specifier, base, conditions) {
     return new URL('node:' + specifier);
   }
 
+  const electronSpecifiers = new SafeSet(electronTypes);
+  if (electronSpecifiers.has(specifier)) {
+    return new URL('electron:electron');
+  }
+
   const { packageJSONUrl, packageJSONPath, packageSubpath } = packageJsonReader.getPackageJSONURL(specifier, base);
 
   const packageConfig = packageJsonReader.read(packageJSONPath, { __proto__: null, specifier, base, isESM: true });
diff --git a/lib/internal/modules/esm/translators.js b/lib/internal/modules/esm/translators.js
index 1716328c7a98996a8933dbaa00a1c6c3156fb2ff..30f887663bbbd9913eff35f0e6e5b8291adda120 100644
--- a/lib/internal/modules/esm/translators.js
+++ b/lib/internal/modules/esm/translators.js
@@ -223,7 +223,9 @@ function createCJSModuleWrap(url, translateContext, parentURL, loadCJS = loadCJS
   const { exportNames, module } = cjsPreparseModuleExports(filename, source, sourceFormat);
   cjsCache.set(url, module);
 
-  const wrapperNames = [...exportNames];
+  const wrapperNames = filename === 'electron' ?
+    ['default', ...Object.keys(module.exports)] :
+    [...exportNames];
   if (!exportNames.has('default')) {
     ArrayPrototypePush(wrapperNames, 'default');
   }
@@ -325,6 +327,10 @@ translators.set('require-commonjs', (url, translateContext, parentURL) => {
   return createCJSModuleWrap(url, translateContext, parentURL);
 });
 
+translators.set('electron', () => {
+  return createCJSModuleWrap('electron', { source: '' });
+});
+
 // Handle CommonJS modules referenced by `require` calls.
 // This translator function must be sync, as `require` is sync.
 translators.set('require-commonjs-typescript', (url, translateContext, parentURL) => {
diff --git a/lib/internal/url.js b/lib/internal/url.js
index 813208f39e6622a43ae27ba0cc5d11d1e0de55c1..1c1e6075ebabbdbc29d811fcb9f911ee29b28f9e 100644
--- a/lib/internal/url.js
+++ b/lib/internal/url.js
@@ -1604,6 +1604,8 @@ function fileURLToPath(path, options = kEmptyObject) {
     path = new URL(path);
   else if (!isURL(path))
     throw new ERR_INVALID_ARG_TYPE('path', ['string', 'URL'], path);
+  if (path.protocol === 'electron:')
+    return 'electron';
   if (path.protocol !== 'file:')
     throw new ERR_INVALID_URL_SCHEME('file');
   return (windows ?? isWindows) ? getPathFromURLWin32(path) : getPathFromURLPosix(path);
