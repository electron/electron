From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Adam Klein <adamk@chromium.org>
Date: Wed, 15 May 2024 09:16:00 +0200
Subject: cherry-pick: src: remove calls to recently deprecated V8 APIs

Node.js Commit: a6d54f179d997497a95c18456bef6bc3ee15e2c4
Node.js PR: https://github.com/nodejs/node/pull/52996
V8 API Removal CL: https://chromium-review.googlesource.com/c/v8/v8/+/5539888

This patch is slightly modified from the original commit in order to
resolve conflicts due to the base commit difference between the Node.js
PR and the current upgrade roll.

This patch is expected to be deleted once we catch up with a Node.js
upgrade that includes the original Node.js commit above.

diff --git a/src/module_wrap.cc b/src/module_wrap.cc
index 0f0b16fcdd..094d12ffe9 100644
--- a/src/module_wrap.cc
+++ b/src/module_wrap.cc
@@ -304,8 +304,7 @@ MaybeLocal<Module> ModuleWrap::CompileSourceTextModule(
     bool* cache_rejected) {
   Isolate* isolate = realm->isolate();
   EscapableHandleScope scope(isolate);
-  ScriptOrigin origin(isolate,
-                      url,
+  ScriptOrigin origin(url,
                       line_offset,
                       column_offset,
                       true,            // is cross origin
@@ -500,7 +499,6 @@ void ModuleWrap::Evaluate(const FunctionCallbackInfo<Value>& args) {
 
   ShouldNotAbortOnUncaughtScope no_abort_scope(realm->env());
   TryCatchScope try_catch(realm->env());
-  Isolate::SafeForTerminationScope safe_for_termination(isolate);
 
   bool timed_out = false;
   bool received_signal = false;
@@ -1009,8 +1007,7 @@ void ModuleWrap::CreateRequiredModuleFacade(
   ASSIGN_OR_RETURN_UNWRAP(&original, wrap);
 
   // Use the same facade source and URL to hit the compilation cache.
-  ScriptOrigin origin(isolate,
-                      env->required_module_facade_url_string(),
+  ScriptOrigin origin(env->required_module_facade_url_string(),
                       0,               // line offset
                       0,               // column offset
                       true,            // is cross origin
diff --git a/src/node_builtins.cc b/src/node_builtins.cc
index 4bf80aa6cc6385dc376fd0a3538efc27fe5bd0a2..3e37aa8b0c9696cceb3f3cfab9721f38c74a2fba 100644
--- a/src/node_builtins.cc
+++ b/src/node_builtins.cc
@@ -267,7 +267,7 @@ MaybeLocal<Function> BuiltinLoader::LookupAndCompileInternal(
   std::string filename_s = std::string("node:") + id;
   Local<String> filename =
       OneByteString(isolate, filename_s.c_str(), filename_s.size());
-  ScriptOrigin origin(isolate, filename, 0, 0, true);
+  ScriptOrigin origin(filename, 0, 0, true);
 
   BuiltinCodeCacheData cached_data{};
   {
diff --git a/src/node_contextify.cc b/src/node_contextify.cc
index 6456d87d4202c013aafe071adbac06852b3ae2c1..28ba7dbe66a44a43c39e3d75edf0be9513bcf732 100644
--- a/src/node_contextify.cc
+++ b/src/node_contextify.cc
@@ -878,8 +878,7 @@ void ContextifyScript::New(const FunctionCallbackInfo<Value>& args) {
   host_defined_options->Set(
       isolate, loader::HostDefinedOptions::kID, id_symbol);
 
-  ScriptOrigin origin(isolate,
-                      filename,
+  ScriptOrigin origin(filename,
                       line_offset,                          // line offset
                       column_offset,                        // column offset
                       true,                                 // is cross origin
@@ -999,7 +998,7 @@ MaybeLocal<Function> CompileFunction(Local<Context> context,
                                      Local<String> filename,
                                      Local<String> content,
                                      std::vector<Local<String>>* parameters) {
-  ScriptOrigin script_origin(context->GetIsolate(), filename, 0, 0, true);
+  ScriptOrigin script_origin(filename, 0, 0, true);
   ScriptCompiler::Source script_source(content, script_origin);
 
   return ScriptCompiler::CompileFunction(context,
@@ -1109,7 +1108,6 @@ bool ContextifyScript::EvalMachine(Local<Context> context,
   }
 
   TryCatchScope try_catch(env);
-  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());
   ContextifyScript* wrapped_script;
   ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.This(), false);
   Local<UnboundScript> unbound_script =
@@ -1278,8 +1276,7 @@ void ContextifyContext::CompileFunction(
   Local<PrimitiveArray> host_defined_options =
       loader::ModuleWrap::GetHostDefinedOptions(isolate, id_symbol);
 
-  ScriptOrigin origin(isolate,
-                      filename,
+  ScriptOrigin origin(filename,
                       line_offset,     // line offset
                       column_offset,   // column offset
                       true,            // is cross origin
@@ -1466,8 +1463,7 @@ static MaybeLocal<Function> CompileFunctionForCJSLoader(
   Local<Symbol> symbol = env->vm_dynamic_import_default_internal();
   Local<PrimitiveArray> hdo =
       loader::ModuleWrap::GetHostDefinedOptions(isolate, symbol);
-  ScriptOrigin origin(isolate,
-                      filename,
+  ScriptOrigin origin(filename,
                       0,               // line offset
                       0,               // column offset
                       true,            // is cross origin
diff --git a/test/cctest/test_environment.cc b/test/cctest/test_environment.cc
index 64e38c83006a004ebc3519a5e9f8b04263244514..14e82cc80ff73084fb43b2ef07febfd2667a0abc 100644
--- a/test/cctest/test_environment.cc
+++ b/test/cctest/test_environment.cc
@@ -620,12 +620,9 @@ TEST_F(EnvironmentTest, SetImmediateMicrotasks) {
 
 #ifndef _WIN32  // No SIGINT on Windows.
 TEST_F(NodeZeroIsolateTestFixture, CtrlCWithOnlySafeTerminationTest) {
-  // We need to go through the whole setup dance here because we want to
-  // set only_terminate_in_safe_scope.
   // Allocate and initialize Isolate.
   v8::Isolate::CreateParams create_params;
   create_params.array_buffer_allocator = allocator.get();
-  create_params.only_terminate_in_safe_scope = true;
   v8::Isolate* isolate = v8::Isolate::Allocate();
   CHECK_NOT_NULL(isolate);
   platform->RegisterIsolate(isolate, &current_loop);
