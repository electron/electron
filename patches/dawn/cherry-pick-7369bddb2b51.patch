From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Peter McNeeley <petermcneeley@google.com>
Date: Mon, 1 Dec 2025 09:10:36 -0800
Subject: [tint] Polyfill unary negation and abs for amd mesa frontend

Bug: 448294721
Change-Id: Ibca22bac11a7289538cefcd70169640d323b297c
Reviewed-on: https://dawn-review.googlesource.com/c/dawn/+/276774
Reviewed-by: James Price <jrprice@google.com>
Commit-Queue: Peter McNeeley <petermcneeley@google.com>

diff --git a/src/dawn/native/Toggles.cpp b/src/dawn/native/Toggles.cpp
index af7da98587f0087d5f06e09735c3c5686a2b4d09..a24a390a536d0e1faeb59a9ca5918869031b054f 100644
--- a/src/dawn/native/Toggles.cpp
+++ b/src/dawn/native/Toggles.cpp
@@ -387,6 +387,13 @@ static constexpr ToggleEnumAndInfoList kToggleNameAndInfoList = {{
      {"metal_polyfill_unpack_2x16_unorm",
       "Polyfill unpack2x16unorm for MSL due to CTS failures on Mac M3+ devices.",
       "https://crbug.com/449576833", ToggleStage::Device}},
+    {Toggle::VulkanPolyfillF32Negation,
+     {"spirv_polyfill_f32_negation",
+      "Polyfill f32 negation with bit manipulation in SPIR-V writer.",
+      "https://crbug.com/448294721", ToggleStage::Device}},
+    {Toggle::VulkanPolyfillF32Abs,
+     {"spirv_polyfill_f32_abs", "Polyfill f32 abs with bit manipulation in SPIR-V writer.",
+      "https://crbug.com/448294721", ToggleStage::Device}},
     {Toggle::MetalFillEmptyOcclusionQueriesWithZero,
      {"metal_fill_empty_occlusion_queries_with_zero",
       "Apple GPUs leave stale results in the visibility result buffer instead of writing zero if "
diff --git a/src/dawn/native/Toggles.h b/src/dawn/native/Toggles.h
index d663bbbcb643191c72955eeefd07f3afc46a4c63..1aad42450658567eab7b89ceb20f11e3a2f6b50d 100644
--- a/src/dawn/native/Toggles.h
+++ b/src/dawn/native/Toggles.h
@@ -104,6 +104,8 @@ enum class Toggle {
     MetalKeepMultisubresourceDepthStencilTexturesInitialized,
     MetalPolyfillUnpack2x16snorm,
     MetalPolyfillUnpack2x16unorm,
+    VulkanPolyfillF32Negation,
+    VulkanPolyfillF32Abs,
     MetalFillEmptyOcclusionQueriesWithZero,
     UseBlitForBufferToDepthTextureCopy,
     UseBlitForBufferToStencilTextureCopy,
diff --git a/src/dawn/native/vulkan/PhysicalDeviceVk.cpp b/src/dawn/native/vulkan/PhysicalDeviceVk.cpp
index 45271dfbfb247acc492f050a02b6fcc771516482..64ebd4151e2b5729ce944892a91298ccb027c643 100644
--- a/src/dawn/native/vulkan/PhysicalDeviceVk.cpp
+++ b/src/dawn/native/vulkan/PhysicalDeviceVk.cpp
@@ -998,6 +998,17 @@ void PhysicalDevice::SetupBackendDeviceToggles(dawn::platform::Platform* platfor
         deviceToggles->Default(Toggle::VulkanPolyfillSwitchWithIf, true);
     }
 
+    // AMD mesa front end optimizer bug for unary negation and abs.
+    // Fixed in 25.3 - See crbug.com/448294721
+    if (IsAmdMesa()) {
+        const gpu_info::DriverVersion kGoodMesaDriver = {25, 3, 0, 0};
+        const bool badDriver = GetDriverVersion() < kGoodMesaDriver;
+        if (badDriver) {
+            deviceToggles->Default(Toggle::VulkanPolyfillF32Abs, true);
+            deviceToggles->Default(Toggle::VulkanPolyfillF32Negation, true);
+        }
+    }
+
     if (IsAndroidARM()) {
         // dawn:1550: Resolving multiple color targets in a single pass fails on ARM GPUs. To
         // work around the issue, passes that resolve to multiple color targets will instead be
@@ -1285,6 +1296,13 @@ bool PhysicalDevice::IsIntelMesa() const {
     return false;
 }
 
+bool PhysicalDevice::IsAmdMesa() const {
+    if (mDeviceInfo.HasExt(DeviceExt::DriverProperties)) {
+        return mDeviceInfo.driverProperties.driverID == VK_DRIVER_ID_MESA_RADV_KHR;
+    }
+    return false;
+}
+
 bool PhysicalDevice::IsSwiftshader() const {
     return gpu_info::IsGoogleSwiftshader(GetVendorId(), GetDeviceId());
 }
diff --git a/src/dawn/native/vulkan/PhysicalDeviceVk.h b/src/dawn/native/vulkan/PhysicalDeviceVk.h
index 622e2b9fb942b5e53c632303ae08c5df9cc6c5fa..1926898038ddacb6b5fe4f075b0bc7b0e4b57e69 100644
--- a/src/dawn/native/vulkan/PhysicalDeviceVk.h
+++ b/src/dawn/native/vulkan/PhysicalDeviceVk.h
@@ -67,6 +67,7 @@ class PhysicalDevice : public PhysicalDeviceBase {
     bool IsAndroidImgTec() const;
     bool IsPixel10() const;
     bool IsIntelMesa() const;
+    bool IsAmdMesa() const;
     bool IsAndroidHuawei() const;
     bool IsSwiftshader() const;
 
diff --git a/src/dawn/native/vulkan/ShaderModuleVk.cpp b/src/dawn/native/vulkan/ShaderModuleVk.cpp
index d9ee0aedf640eac129601c0926980c83e9ca8ab7..ca6e06b73b64df2e53f789df898ff57982f4bd95 100644
--- a/src/dawn/native/vulkan/ShaderModuleVk.cpp
+++ b/src/dawn/native/vulkan/ShaderModuleVk.cpp
@@ -214,6 +214,33 @@ ResultOrError<ShaderModule::ModuleAndSpirv> ShaderModule::GetHandleAndSpirv(
     };
     req.tintOptions.disable_workgroup_init =
         GetDevice()->IsToggleEnabled(Toggle::DisableWorkgroupInit);
+    req.tintOptions.bindings = std::move(bindings);
+    req.tintOptions.resource_binding = std::move(resourceBindingConfig);
+
+    req.tintOptions.workarounds.polyfill_unary_f32_negation =
+        GetDevice()->IsToggleEnabled(Toggle::VulkanPolyfillF32Negation);
+    req.tintOptions.workarounds.polyfill_f32_abs =
+        GetDevice()->IsToggleEnabled(Toggle::VulkanPolyfillF32Abs);
+    req.tintOptions.disable_polyfill_integer_div_mod =
+        GetDevice()->IsToggleEnabled(Toggle::DisablePolyfillsOnIntegerDivisonAndModulo);
+
+    req.tintOptions.emit_vertex_point_size = emitPointSize;
+    req.tintOptions.apply_pixel_center_polyfill = isSampled;
+
+    req.tintOptions.spirv_version = GetDevice()->IsToggleEnabled(Toggle::UseSpirv14)
+                                        ? tint::spirv::writer::SpvVersion::kSpv14
+                                        : tint::spirv::writer::SpvVersion::kSpv13;
+    req.tintOptions.enable_integer_range_analysis =
+        GetDevice()->IsToggleEnabled(Toggle::EnableIntegerRangeAnalysisInRobustness);
+
+    req.tintOptions.extensions.use_vulkan_memory_model =
+        GetDevice()->IsToggleEnabled(Toggle::UseVulkanMemoryModel);
+    // Currently we can disable index clamping on all runtime-sized arrays in Tint robustness
+    // transform as unsized arrays can only be declared on storage address space.
+    req.tintOptions.extensions.disable_runtime_sized_array_index_clamping =
+        GetDevice()->IsToggleEnabled(Toggle::VulkanUseBufferRobustAccess2);
+    req.tintOptions.extensions.disable_image_robustness =
+        GetDevice()->IsToggleEnabled(Toggle::VulkanUseImageRobustAccess2);
     // The only possible alternative for the vulkan demote to helper extension is
     // "OpTerminateInvocation" which remains unimplemented in dawn/tint.
     req.tintOptions.use_demote_to_helper_invocation_extensions =
diff --git a/src/tint/lang/spirv/writer/common/options.h b/src/tint/lang/spirv/writer/common/options.h
index 6ba437ea529ff59a1f0761c2b111433184159948..98cdb20516d517ecff06c1e32d7e93bb4c2e06a5 100644
--- a/src/tint/lang/spirv/writer/common/options.h
+++ b/src/tint/lang/spirv/writer/common/options.h
@@ -65,6 +65,89 @@ struct Options {
         TINT_REFLECT(RangeOffsets, min, max);
     };
 
+    /// The set of options which control workarounds for driver issues in the SPIR-V generator.
+    struct Workarounds {
+        /// Set to `true` to generate a polyfill for switch statements using if/else statements.
+        bool polyfill_case_switch = false;
+
+        /// Set to `true` to scalarize max min and clamp builtins.
+        bool scalarize_max_min_clamp = false;
+
+        /// Set to `true` if handles should be transformed by direct variable access.
+        bool dva_transform_handle = false;
+
+        /// Set to `true` to generate polyfill for `pack4x8snorm`, `pack4x8unorm`, `unpack4x8snorm`
+        /// and `unpack4x8unorm` builtins
+        bool polyfill_pack_unpack_4x8_norm = false;
+
+        /// Set to `true` to generate a polyfill clamp of `id` param of subgroupShuffle to within
+        /// the spec max subgroup size.
+        bool subgroup_shuffle_clamped = false;
+
+        /// Set to `true` to generate polyfill for `subgroupBroadcast(f16)`
+        bool polyfill_subgroup_broadcast_f16 = false;
+
+        /// Set to `true` to always pass matrices to user functions by pointer instead of by value.
+        bool pass_matrix_by_pointer = false;
+
+        /// Set to `true` to generate polyfill for f32 negation.
+        bool polyfill_unary_f32_negation = false;
+
+        /// Set to `true` to generate polyfill for f32 abs.
+        bool polyfill_f32_abs = false;
+
+        TINT_REFLECT(Workarounds,
+                     polyfill_case_switch,
+                     scalarize_max_min_clamp,
+                     dva_transform_handle,
+                     polyfill_pack_unpack_4x8_norm,
+                     subgroup_shuffle_clamped,
+                     polyfill_subgroup_broadcast_f16,
+                     pass_matrix_by_pointer,
+                     polyfill_unary_f32_negation,
+                     polyfill_f32_abs);
+    };
+
+    /// Any options which are controlled by the presence/absence of a vulkan extension.
+    struct Extensions {
+        /// Set to `true` to allow for the usage of the demote to helper extension.
+        bool use_demote_to_helper_invocation = false;
+
+        /// Set to `true` to use the StorageInputOutput16 capability for shader IO that uses f16
+        /// types.
+        bool use_storage_input_output_16 = true;
+
+        /// Set to `true` to initialize workgroup memory with OpConstantNull when
+        /// VK_KHR_zero_initialize_workgroup_memory is enabled.
+        bool use_zero_initialize_workgroup_memory = false;
+
+        /// Set to `true` if the Vulkan Memory Model should be used
+        bool use_vulkan_memory_model = false;
+
+        /// Set to `true` to skip robustness transform on textures.
+        bool disable_image_robustness = false;
+
+        /// Set to `true` to disable index clamping on the runtime-sized arrays in robustness
+        /// transform.
+        bool disable_runtime_sized_array_index_clamping = false;
+
+        /// Set to `true` to generate polyfill for `dot4I8Packed` and `dot4U8Packed` builtins
+        bool dot_4x8_packed = false;
+
+        /// Set to `true` to decompose uniform buffers into array<vec4u, ...>.
+        bool decompose_uniform_buffers = true;
+
+        TINT_REFLECT(Extensions,
+                     use_demote_to_helper_invocation,
+                     use_storage_input_output_16,
+                     use_zero_initialize_workgroup_memory,
+                     use_vulkan_memory_model,
+                     disable_image_robustness,
+                     disable_runtime_sized_array_index_clamping,
+                     dot_4x8_packed,
+                     decompose_uniform_buffers);
+    };
+
     /// The entry point name to generate
     std::string entry_point_name;
 
diff --git a/src/tint/lang/spirv/writer/raise/BUILD.bazel b/src/tint/lang/spirv/writer/raise/BUILD.bazel
index 80e7efae1b2989a888d233c2fbb1da522a612f64..9a3783a561774bf7a50b08ac80146e4a0f567435 100644
--- a/src/tint/lang/spirv/writer/raise/BUILD.bazel
+++ b/src/tint/lang/spirv/writer/raise/BUILD.bazel
@@ -51,6 +51,7 @@ cc_library(
     "remove_unreachable_in_loop_continuing.cc",
     "resource_binding.cc",
     "shader_io.cc",
+    "unary_polyfill.cc",
     "var_for_dynamic_index.cc",
   ],
   hdrs = [
@@ -66,6 +67,7 @@ cc_library(
     "remove_unreachable_in_loop_continuing.h",
     "resource_binding.h",
     "shader_io.h",
+    "unary_polyfill.h",
     "var_for_dynamic_index.h",
   ],
   deps = [
@@ -120,6 +122,7 @@ cc_library(
     "pass_matrix_by_pointer_test.cc",
     "remove_unreachable_in_loop_continuing_test.cc",
     "shader_io_test.cc",
+    "unary_polyfill_test.cc",
     "var_for_dynamic_index_test.cc",
   ],
   deps = [
diff --git a/src/tint/lang/spirv/writer/raise/BUILD.cmake b/src/tint/lang/spirv/writer/raise/BUILD.cmake
index 8150d9e98e1f2c64921bfa6f600f25eff945c351..32cf5191adb8a325b6de21c9c663836de5b0d25c 100644
--- a/src/tint/lang/spirv/writer/raise/BUILD.cmake
+++ b/src/tint/lang/spirv/writer/raise/BUILD.cmake
@@ -65,6 +65,8 @@ tint_add_target(tint_lang_spirv_writer_raise lib
   lang/spirv/writer/raise/resource_binding.h
   lang/spirv/writer/raise/shader_io.cc
   lang/spirv/writer/raise/shader_io.h
+  lang/spirv/writer/raise/unary_polyfill.cc
+  lang/spirv/writer/raise/unary_polyfill.h
   lang/spirv/writer/raise/var_for_dynamic_index.cc
   lang/spirv/writer/raise/var_for_dynamic_index.h
 )
@@ -128,6 +130,7 @@ tint_add_target(tint_lang_spirv_writer_raise_test test
   lang/spirv/writer/raise/pass_matrix_by_pointer_test.cc
   lang/spirv/writer/raise/remove_unreachable_in_loop_continuing_test.cc
   lang/spirv/writer/raise/shader_io_test.cc
+  lang/spirv/writer/raise/unary_polyfill_test.cc
   lang/spirv/writer/raise/var_for_dynamic_index_test.cc
 )
 
diff --git a/src/tint/lang/spirv/writer/raise/BUILD.gn b/src/tint/lang/spirv/writer/raise/BUILD.gn
index c4c229bb6d0f2600737804837d8c54d701db3b25..380df74a71c51f929901b3eb50615489ce6a57bd 100644
--- a/src/tint/lang/spirv/writer/raise/BUILD.gn
+++ b/src/tint/lang/spirv/writer/raise/BUILD.gn
@@ -69,6 +69,8 @@ if (tint_build_spv_writer) {
       "resource_binding.h",
       "shader_io.cc",
       "shader_io.h",
+      "unary_polyfill.cc",
+      "unary_polyfill.h",
       "var_for_dynamic_index.cc",
       "var_for_dynamic_index.h",
     ]
@@ -121,6 +123,7 @@ if (tint_build_unittests) {
         "pass_matrix_by_pointer_test.cc",
         "remove_unreachable_in_loop_continuing_test.cc",
         "shader_io_test.cc",
+        "unary_polyfill_test.cc",
         "var_for_dynamic_index_test.cc",
       ]
       deps = [
diff --git a/src/tint/lang/spirv/writer/raise/raise.cc b/src/tint/lang/spirv/writer/raise/raise.cc
index 04582992b63428dbaa2d170cdacf5bd23aaef58d..1c22fe7aed70e4fc5b7dacd07f4f9711911ac87f 100644
--- a/src/tint/lang/spirv/writer/raise/raise.cc
+++ b/src/tint/lang/spirv/writer/raise/raise.cc
@@ -65,6 +65,7 @@
 #include "src/tint/lang/spirv/writer/raise/remove_unreachable_in_loop_continuing.h"
 #include "src/tint/lang/spirv/writer/raise/resource_binding.h"
 #include "src/tint/lang/spirv/writer/raise/shader_io.h"
+#include "src/tint/lang/spirv/writer/raise/unary_polyfill.h"
 #include "src/tint/lang/spirv/writer/raise/var_for_dynamic_index.h"
 
 namespace tint::spirv::writer {
@@ -222,6 +223,14 @@ Result<SuccessType> Raise(core::ir::Module& module, const Options& options) {
         .signed_negation = true, .signed_arithmetic = true, .signed_shiftleft = true};
     RUN_TRANSFORM(core::ir::transform::SignedIntegerPolyfill, module, signed_integer_cfg);
 
+    // AMD mesa front end optimizer bug for unary negation and abs.
+    // Fixed in 25.3 - See crbug.com/448294721
+    raise::UnaryPolyfillConfig unary_polyfill_cfg = {
+        .polyfill_f32_negation = options.workarounds.polyfill_unary_f32_negation,
+        .polyfill_f32_abs = options.workarounds.polyfill_f32_abs};
+
+    RUN_TRANSFORM(raise::UnaryPolyfill, module, unary_polyfill_cfg);
+
     // kAllowAnyInputAttachmentIndexType required after ExpandImplicitSplats
     RUN_TRANSFORM(raise::HandleMatrixArithmetic, module);
     RUN_TRANSFORM(raise::MergeReturn, module);
diff --git a/src/tint/lang/spirv/writer/raise/unary_polyfill.cc b/src/tint/lang/spirv/writer/raise/unary_polyfill.cc
new file mode 100644
index 0000000000000000000000000000000000000000..75c4bcd98132e7feb3345d0fed551b8092f1d8ce
--- /dev/null
+++ b/src/tint/lang/spirv/writer/raise/unary_polyfill.cc
@@ -0,0 +1,124 @@
+// Copyright 2025 The Dawn & Tint Authors
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its
+//    contributors may be used to endorse or promote products derived from
+//    this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "src/tint/lang/spirv/writer/raise/unary_polyfill.h"
+
+#include "src/tint/lang/core/ir/builder.h"
+#include "src/tint/lang/core/ir/module.h"
+#include "src/tint/lang/core/ir/validator.h"
+#include "src/tint/utils/result.h"
+
+using namespace tint::core::fluent_types;     // NOLINT
+using namespace tint::core::number_suffixes;  // NOLINT
+
+namespace tint::spirv::writer::raise {
+
+namespace {
+
+struct State {
+    core::ir::Module& ir;
+    UnaryPolyfillConfig config;
+    core::ir::Builder b{ir};
+    core::type::Manager& ty{ir.Types()};
+
+    void Process() {
+        Vector<core::ir::Unary*, 4> unary_worklist;
+        Vector<core::ir::CoreBuiltinCall*, 4> builtin_worklist;
+        for (auto* inst : ir.Instructions()) {
+            if (auto* unary = inst->As<core::ir::Unary>()) {
+                if (config.polyfill_f32_negation && unary->Op() == core::UnaryOp::kNegation &&
+                    unary->Result()->Type()->DeepestElement()->Is<core::type::F32>()) {
+                    unary_worklist.Push(unary);
+                }
+            } else if (auto* builtin = inst->As<core::ir::CoreBuiltinCall>()) {
+                if (config.polyfill_f32_abs && builtin->Func() == core::BuiltinFn::kAbs &&
+                    builtin->Result()->Type()->DeepestElement()->Is<core::type::F32>()) {
+                    builtin_worklist.Push(builtin);
+                }
+            }
+        }
+
+        for (auto* unary : unary_worklist) {
+            PolyfillF32Negation(unary);
+        }
+        for (auto* builtin : builtin_worklist) {
+            PolyfillF32Abs(builtin);
+        }
+    }
+
+    void PolyfillF32Negation(core::ir::Unary* unary) {
+        auto* val = unary->Val();
+        auto* type = val->Type();
+
+        // AMD mesa front end optimizer bug for unary negation and abs.
+        // Fixed in 25.3 - See crbug.com/448294721
+        // Note we use bitcast as a hammer to avoid the optimizer seeing through other possible
+        // workarounds.
+        b.InsertBefore(unary, [&] {
+            auto* uint_ty = ty.MatchWidth(ty.u32(), type);
+            auto* u32_val = b.Bitcast(uint_ty, val);
+            auto* mask = b.MatchWidth(0x80000000_u, uint_ty);
+            auto* xor_res = b.Xor(uint_ty, u32_val, mask);
+            b.BitcastWithResult(unary->DetachResult(), xor_res->Result());
+        });
+        unary->Destroy();
+    }
+
+    void PolyfillF32Abs(core::ir::CoreBuiltinCall* builtin) {
+        auto* val = builtin->Args()[0];
+        auto* type = val->Type();
+
+        // AMD mesa front end optimizer bug for unary negation and abs.
+        // Fixed in 25.3 - See crbug.com/448294721
+        // Note we use bitcast as a hammer to avoid the optimizer seeing through other possible
+        // workarounds.
+        b.InsertBefore(builtin, [&] {
+            auto* uint_ty = ty.MatchWidth(ty.u32(), type);
+            auto* u32_val = b.Bitcast(uint_ty, val);
+            auto* mask = b.MatchWidth(0x7FFFFFFF_u, uint_ty);
+            auto* and_res = b.And(uint_ty, u32_val, mask);
+            b.BitcastWithResult(builtin->DetachResult(), and_res->Result());
+        });
+        builtin->Destroy();
+    }
+};
+
+}  // namespace
+
+Result<SuccessType> UnaryPolyfill(core::ir::Module& module, const UnaryPolyfillConfig& config) {
+    auto result =
+        ValidateAndDumpIfNeeded(module, "spirv.UnaryPolyfill", kPolyfillUnaryCapabilities);
+    if (result != Success) {
+        return result.Failure();
+    }
+
+    State{module, config}.Process();
+
+    return Success;
+}
+
+}  // namespace tint::spirv::writer::raise
diff --git a/src/tint/lang/spirv/writer/raise/unary_polyfill.h b/src/tint/lang/spirv/writer/raise/unary_polyfill.h
new file mode 100644
index 0000000000000000000000000000000000000000..36bf2f6cccab6e5b0688f25198ddde95f90c9dd1
--- /dev/null
+++ b/src/tint/lang/spirv/writer/raise/unary_polyfill.h
@@ -0,0 +1,65 @@
+// Copyright 2025 The Dawn & Tint Authors
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its
+//    contributors may be used to endorse or promote products derived from
+//    this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef SRC_TINT_LANG_SPIRV_WRITER_RAISE_UNARY_POLYFILL_H_
+#define SRC_TINT_LANG_SPIRV_WRITER_RAISE_UNARY_POLYFILL_H_
+
+#include "src/tint/lang/core/ir/validator.h"
+#include "src/tint/utils/result.h"
+
+// Forward declarations.
+namespace tint::core::ir {
+class Module;
+}  // namespace tint::core::ir
+
+namespace tint::spirv::writer::raise {
+
+// The capabilities that the transform can support.
+const core::ir::Capabilities kPolyfillUnaryCapabilities{
+    core::ir::Capability::kAllowDuplicateBindings,
+    core::ir::Capability::kAllowAnyInputAttachmentIndexType,
+    core::ir::Capability::kAllowNonCoreTypes,
+    core::ir::Capability::kAllow8BitIntegers,
+};
+
+/// Configuration for the UnaryPolyfill transform.
+struct UnaryPolyfillConfig {
+    /// If true, polyfill f32 negation with bit manipulation.
+    bool polyfill_f32_negation = false;
+    /// If true, polyfill f32 abs with sign() * x.
+    bool polyfill_f32_abs = false;
+};
+
+/// UnaryPolyfill is a transform that replaces unary instructions with polyfills.
+/// @param module the module to transform
+/// @param config the configuration used in the polyfill function
+/// @returns success or failure
+Result<SuccessType> UnaryPolyfill(core::ir::Module& module, const UnaryPolyfillConfig& config);
+
+}  // namespace tint::spirv::writer::raise
+
+#endif  // SRC_TINT_LANG_SPIRV_WRITER_RAISE_UNARY_POLYFILL_H_
diff --git a/src/tint/lang/spirv/writer/raise/unary_polyfill_test.cc b/src/tint/lang/spirv/writer/raise/unary_polyfill_test.cc
new file mode 100644
index 0000000000000000000000000000000000000000..648c5bf6ef57ccc9d6f60ffd1190e383f5b3d605
--- /dev/null
+++ b/src/tint/lang/spirv/writer/raise/unary_polyfill_test.cc
@@ -0,0 +1,247 @@
+// Copyright 2025 The Dawn & Tint Authors
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its
+//    contributors may be used to endorse or promote products derived from
+//    this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "src/tint/lang/spirv/writer/raise/unary_polyfill.h"
+
+#include "src/tint/lang/core/ir/transform/helper_test.h"
+
+namespace tint::spirv::writer::raise {
+namespace {
+
+using namespace tint::core::fluent_types;     // NOLINT
+using namespace tint::core::number_suffixes;  // NOLINT
+
+using SpirvWriter_UnaryPolyfillTest = core::ir::transform::TransformTest;
+
+TEST_F(SpirvWriter_UnaryPolyfillTest, Negation_Scalar) {
+    auto* arg = b.FunctionParam("arg", ty.f32());
+    auto* func = b.Function("foo", ty.f32());
+    func->SetParams({arg});
+
+    b.Append(func->Block(), [&] {
+        auto* result = b.Negation(arg);
+        b.Return(func, result);
+    });
+
+    auto* src = R"(
+%foo = func(%arg:f32):f32 {
+  $B1: {
+    %3:f32 = negation %arg
+    ret %3
+  }
+}
+)";
+    EXPECT_EQ(src, str());
+
+    auto* expect = R"(
+%foo = func(%arg:f32):f32 {
+  $B1: {
+    %3:u32 = bitcast %arg
+    %4:u32 = xor %3, 2147483648u
+    %5:f32 = bitcast %4
+    ret %5
+  }
+}
+)";
+
+    UnaryPolyfillConfig config;
+    config.polyfill_f32_negation = true;
+    Run(UnaryPolyfill, config);
+
+    EXPECT_EQ(expect, str());
+}
+
+TEST_F(SpirvWriter_UnaryPolyfillTest, Negation_Vector) {
+    auto* arg = b.FunctionParam("arg", ty.vec4<f32>());
+    auto* func = b.Function("foo", ty.vec4<f32>());
+    func->SetParams({arg});
+
+    b.Append(func->Block(), [&] {
+        auto* result = b.Negation(arg);
+        b.Return(func, result);
+    });
+
+    auto* src = R"(
+%foo = func(%arg:vec4<f32>):vec4<f32> {
+  $B1: {
+    %3:vec4<f32> = negation %arg
+    ret %3
+  }
+}
+)";
+    EXPECT_EQ(src, str());
+
+    auto* expect = R"(
+%foo = func(%arg:vec4<f32>):vec4<f32> {
+  $B1: {
+    %3:vec4<u32> = bitcast %arg
+    %4:vec4<u32> = xor %3, vec4<u32>(2147483648u)
+    %5:vec4<f32> = bitcast %4
+    ret %5
+  }
+}
+)";
+
+    UnaryPolyfillConfig config;
+    config.polyfill_f32_negation = true;
+    Run(UnaryPolyfill, config);
+
+    EXPECT_EQ(expect, str());
+}
+
+TEST_F(SpirvWriter_UnaryPolyfillTest, Abs_Scalar) {
+    auto* arg = b.FunctionParam("arg", ty.f32());
+    auto* func = b.Function("foo", ty.f32());
+    func->SetParams({arg});
+
+    b.Append(func->Block(), [&] {
+        auto* result = b.Call(ty.f32(), core::BuiltinFn::kAbs, arg);
+        b.Return(func, result);
+    });
+
+    auto* src = R"(
+%foo = func(%arg:f32):f32 {
+  $B1: {
+    %3:f32 = abs %arg
+    ret %3
+  }
+}
+)";
+    EXPECT_EQ(src, str());
+
+    auto* expect = R"(
+%foo = func(%arg:f32):f32 {
+  $B1: {
+    %3:u32 = bitcast %arg
+    %4:u32 = and %3, 2147483647u
+    %5:f32 = bitcast %4
+    ret %5
+  }
+}
+)";
+
+    UnaryPolyfillConfig config;
+    config.polyfill_f32_abs = true;
+    Run(UnaryPolyfill, config);
+
+    EXPECT_EQ(expect, str());
+}
+
+TEST_F(SpirvWriter_UnaryPolyfillTest, Abs_Vector) {
+    auto* arg = b.FunctionParam("arg", ty.vec4<f32>());
+    auto* func = b.Function("foo", ty.vec4<f32>());
+    func->SetParams({arg});
+
+    b.Append(func->Block(), [&] {
+        auto* result = b.Call(ty.vec4<f32>(), core::BuiltinFn::kAbs, arg);
+        b.Return(func, result);
+    });
+
+    auto* src = R"(
+%foo = func(%arg:vec4<f32>):vec4<f32> {
+  $B1: {
+    %3:vec4<f32> = abs %arg
+    ret %3
+  }
+}
+)";
+    EXPECT_EQ(src, str());
+
+    auto* expect = R"(
+%foo = func(%arg:vec4<f32>):vec4<f32> {
+  $B1: {
+    %3:vec4<u32> = bitcast %arg
+    %4:vec4<u32> = and %3, vec4<u32>(2147483647u)
+    %5:vec4<f32> = bitcast %4
+    ret %5
+  }
+}
+)";
+
+    UnaryPolyfillConfig config;
+    config.polyfill_f32_abs = true;
+    Run(UnaryPolyfill, config);
+
+    EXPECT_EQ(expect, str());
+}
+
+TEST_F(SpirvWriter_UnaryPolyfillTest, Negation_NoPolyfill) {
+    auto* arg = b.FunctionParam("arg", ty.f32());
+    auto* func = b.Function("foo", ty.f32());
+    func->SetParams({arg});
+
+    b.Append(func->Block(), [&] {
+        auto* result = b.Negation(arg);
+        b.Return(func, result);
+    });
+
+    auto* src = R"(
+%foo = func(%arg:f32):f32 {
+  $B1: {
+    %3:f32 = negation %arg
+    ret %3
+  }
+}
+)";
+    EXPECT_EQ(src, str());
+
+    UnaryPolyfillConfig config;
+    config.polyfill_f32_negation = false;
+    Run(UnaryPolyfill, config);
+
+    EXPECT_EQ(src, str());
+}
+
+TEST_F(SpirvWriter_UnaryPolyfillTest, Abs_NoPolyfill) {
+    auto* arg = b.FunctionParam("arg", ty.f32());
+    auto* func = b.Function("foo", ty.f32());
+    func->SetParams({arg});
+
+    b.Append(func->Block(), [&] {
+        auto* result = b.Call(ty.f32(), core::BuiltinFn::kAbs, arg);
+        b.Return(func, result);
+    });
+
+    auto* src = R"(
+%foo = func(%arg:f32):f32 {
+  $B1: {
+    %3:f32 = abs %arg
+    ret %3
+  }
+}
+)";
+    EXPECT_EQ(src, str());
+
+    UnaryPolyfillConfig config;
+    config.polyfill_f32_abs = false;
+    Run(UnaryPolyfill, config);
+
+    EXPECT_EQ(src, str());
+}
+
+}  // namespace
+}  // namespace tint::spirv::writer::raise
