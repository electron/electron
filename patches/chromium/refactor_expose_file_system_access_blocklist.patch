From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Shelley Vohr <shelley.vohr@gmail.com>
Date: Wed, 27 Mar 2024 10:47:48 +0100
Subject: refactor: expose file system access blocklist

This CL exposes the file system access blocklist publicly so that we can leverage
it in Electron and prevent drift from Chrome's blocklist. We should look for a way
to upstream this change to Chrome.

diff --git a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
index 5b543e82abb17cbb91bf37fa6bac016b6053eb93..5500755603079df80f12d7526069bd059cb3c826 100644
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
@@ -82,11 +82,13 @@
 #include "chrome/browser/ui/browser_window.h"
 #include "chrome/browser/ui/tabs/public/tab_features.h"
 #include "chrome/browser/ui/views/file_system_access/file_system_access_page_action_controller.h"
+#if 0
 #include "chrome/browser/web_applications/proto/web_app_install_state.pb.h"
 #include "chrome/browser/web_applications/web_app_install_manager.h"
 #include "chrome/browser/web_applications/web_app_install_manager_observer.h"
 #include "chrome/browser/web_applications/web_app_provider.h"
 #include "chrome/browser/web_applications/web_app_registrar.h"
+#endif
 #include "components/tabs/public/tab_interface.h"
 #if BUILDFLAG(ENABLE_PLATFORM_APPS)
 #include "extensions/browser/extension_registry.h"  // nogncheck
@@ -1289,7 +1291,7 @@ ChromeFileSystemAccessPermissionContext::
 #if BUILDFLAG(IS_ANDROID)
   one_time_permissions_tracker_.Observe(
       OneTimePermissionsTrackerFactory::GetForBrowserContext(context));
-#else
+#elif 0
   auto* provider = web_app::WebAppProvider::GetForWebApps(
       Profile::FromBrowserContext(profile_));
   if (provider) {
@@ -1335,6 +1337,12 @@ void ChromeFileSystemAccessPermissionContext::ResetBlockPathsForTesting() {
   ResetBlockPaths();
 }
 
+// static
+std::unique_ptr<ChromeFileSystemAccessPermissionContext::BlockPathRules>
+ChromeFileSystemAccessPermissionContext::GetBlockPaths(bool should_normalize_file_path) {
+  return GenerateBlockPaths(should_normalize_file_path);
+}
+
 void ChromeFileSystemAccessPermissionContext::UpdateBlockPaths(
     std::unique_ptr<BlockPathRules> block_path_rules) {
   block_path_rules_ = std::move(block_path_rules);
@@ -2551,7 +2559,7 @@ void ChromeFileSystemAccessPermissionContext::OnShutdown() {
   one_time_permissions_tracker_.Reset();
 }
 
-#if !BUILDFLAG(IS_ANDROID)
+#if 0
 void ChromeFileSystemAccessPermissionContext::OnWebAppInstalled(
     const webapps::AppId& app_id) {
   if (!base::FeatureList::IsEnabled(
@@ -3108,11 +3116,7 @@ bool ChromeFileSystemAccessPermissionContext::OriginHasExtendedPermission(
     const url::Origin& origin) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
-#if BUILDFLAG(IS_ANDROID)
-  // TODO(crbug.com/40101963): Enable when android persisted permissions are
-  // implemented.
-  return false;
-#else
+#if 0
   if (!base::FeatureList::IsEnabled(
           features::kFileSystemAccessPersistentPermissions)) {
     return false;
@@ -3156,6 +3160,7 @@ bool ChromeFileSystemAccessPermissionContext::OriginHasExtendedPermission(
                                             : WebAppInstallStatus::kUninstalled;
   return app_has_os_integration;
 #endif  // BUILDFLAG(IS_ANDROID)
+  return false;
 }
 
 void ChromeFileSystemAccessPermissionContext::SetOriginExtendedPermissionByUser(
diff --git a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
index 5e1aa12c6337e8d0dee9f24d7ec233a894763053..b4bec473071cee2839200b9d5b170ac8f1836770 100644
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
@@ -399,6 +399,8 @@ class ChromeFileSystemAccessPermissionContext
   // This is needed when updating path with ScopedPathOverride.
   void ResetBlockPathsForTesting();
 
+  static std::unique_ptr<BlockPathRules> GetBlockPaths(bool should_normalize_file_path);
+
  protected:
   SEQUENCE_CHECKER(sequence_checker_);
 
