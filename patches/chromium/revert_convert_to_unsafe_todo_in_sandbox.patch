From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Kleinschmidt <kleinschmidtorama@gmail.com>
Date: Wed, 3 Dec 2025 17:22:56 -0500
Subject: Revert "Convert to UNSAFE_TODO in sandbox"

This reverts commit 7567995dbf74ea6c300d8502a565186bf61363d9.

diff --git a/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc b/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
index d9aec9c98f3076ed83ed68635988edbbbd55ecd2..8e0e52ad4b892c0da19a1e5dcafcf1990ef3b94b 100644
--- a/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
+++ b/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include <errno.h>
 #include <fcntl.h>
 #include <pthread.h>
@@ -22,7 +27,6 @@
 #include <memory>
 #include <vector>
 
-#include "base/compiler_specific.h"
 #include "base/containers/adapters.h"
 #include "base/containers/contains.h"
 #include "base/containers/span.h"
@@ -664,7 +668,7 @@ BPF_TEST_C(SandboxBPF, ForwardSyscall, PrctlPolicy) {
   // unaffected by our policy.
   struct utsname uts = {};
   BPF_ASSERT(!uname(&uts));
-  UNSAFE_TODO(BPF_ASSERT(!strcmp(uts.sysname, "Linux")));
+  BPF_ASSERT(!strcmp(uts.sysname, "Linux"));
 }
 
 intptr_t AllowRedirectedSyscall(const struct arch_seccomp_data& args, void*) {
@@ -1697,19 +1701,24 @@ intptr_t PthreadTrapHandler(const struct arch_seccomp_data& args, void* aux) {
     // call. But if we ever get called for anything else, we want to verbosely
     // print as much information as possible.
     const char* msg = (const char*)aux;
-    UNSAFE_TODO(
-        printf("Clone() was called with unexpected arguments\n"
-               "  nr: %d\n"
-               "  1: 0x%llX\n"
-               "  2: 0x%llX\n"
-               "  3: 0x%llX\n"
-               "  4: 0x%llX\n"
-               "  5: 0x%llX\n"
-               "  6: 0x%llX\n"
-               "%s\n",
-               args.nr, (long long)args.args[0], (long long)args.args[1],
-               (long long)args.args[2], (long long)args.args[3],
-               (long long)args.args[4], (long long)args.args[5], msg));
+    printf(
+        "Clone() was called with unexpected arguments\n"
+        "  nr: %d\n"
+        "  1: 0x%llX\n"
+        "  2: 0x%llX\n"
+        "  3: 0x%llX\n"
+        "  4: 0x%llX\n"
+        "  5: 0x%llX\n"
+        "  6: 0x%llX\n"
+        "%s\n",
+        args.nr,
+        (long long)args.args[0],
+        (long long)args.args[1],
+        (long long)args.args[2],
+        (long long)args.args[3],
+        (long long)args.args[4],
+        (long long)args.args[5],
+        msg);
   }
   return -EPERM;
 }
@@ -2064,7 +2073,7 @@ bool FullPwrite64(int fd, const char* buffer, size_t count, off64_t offset) {
       return false;
     }
     count -= transfered;
-    UNSAFE_TODO(buffer += transfered);
+    buffer += transfered;
     offset += transfered;
   }
   return true;
@@ -2077,7 +2086,7 @@ bool FullPread64(int fd, char* buffer, size_t count, off64_t offset) {
       return false;
     }
     count -= transfered;
-    UNSAFE_TODO(buffer += transfered);
+    buffer += transfered;
     offset += transfered;
   }
   return true;
@@ -2131,8 +2140,7 @@ BPF_TEST_C(SandboxBPF, Pread64, TrapPread64Policy) {
                          read_test_string,
                          sizeof(read_test_string),
                          kLargeOffset));
-  UNSAFE_TODO(BPF_ASSERT_EQ(
-      0, memcmp(kTestString, read_test_string, sizeof(kTestString))));
+  BPF_ASSERT_EQ(0, memcmp(kTestString, read_test_string, sizeof(kTestString)));
   BPF_ASSERT(pread_64_was_forwarded);
 }
 
diff --git a/sandbox/linux/integration_tests/seccomp_broker_process_unittest.cc b/sandbox/linux/integration_tests/seccomp_broker_process_unittest.cc
index 4e73c378c771fe05760d7ce1d70d0e58c1f5ab25..11e47ddb20eeee7a774f85d8b728c08c6b50922d 100644
--- a/sandbox/linux/integration_tests/seccomp_broker_process_unittest.cc
+++ b/sandbox/linux/integration_tests/seccomp_broker_process_unittest.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include <errno.h>
 #include <fcntl.h>
 #include <sys/inotify.h>
@@ -14,7 +19,6 @@
 #include <type_traits>
 #include <vector>
 
-#include "base/compiler_specific.h"
 #include "base/files/file.h"
 #include "base/files/file_path.h"
 #include "base/files/file_path_watcher.h"
@@ -952,7 +956,7 @@ class OpenCpuinfoDelegate final : public BrokerTestDelegate {
     // Open cpuinfo directly.
     int cpu_info_fd = HANDLE_EINTR(open(kFileCpuInfo, O_RDONLY));
     BPF_ASSERT_GE(cpu_info_fd, 0);
-    UNSAFE_TODO(memset(cpuinfo_buf_, 1, sizeof(cpuinfo_buf_)));
+    memset(cpuinfo_buf_, 1, sizeof(cpuinfo_buf_));
     read_len_unsandboxed_ =
         HANDLE_EINTR(read(cpu_info_fd, cpuinfo_buf_, sizeof(cpuinfo_buf_)));
     BPF_ASSERT_GT(read_len_unsandboxed_, 0);
@@ -982,7 +986,7 @@ class OpenCpuinfoDelegate final : public BrokerTestDelegate {
     base::ScopedFD cpuinfo_fd_closer(cpuinfo_fd);
     BPF_ASSERT_GE(cpuinfo_fd, 0);
     char buf[3];
-    UNSAFE_TODO(memset(buf, 0, sizeof(buf)));
+    memset(buf, 0, sizeof(buf));
     int read_len_sandboxed = HANDLE_EINTR(read(cpuinfo_fd, buf, sizeof(buf)));
     BPF_ASSERT_GT(read_len_sandboxed, 0);
 
@@ -990,8 +994,7 @@ class OpenCpuinfoDelegate final : public BrokerTestDelegate {
     BPF_ASSERT_EQ(read_len_sandboxed, read_len_unsandboxed_);
     // Compare the cpuinfo as returned by the broker with the one we opened
     // ourselves.
-    UNSAFE_TODO(
-        BPF_ASSERT_EQ(memcmp(buf, cpuinfo_buf_, read_len_sandboxed), 0));
+    BPF_ASSERT_EQ(memcmp(buf, cpuinfo_buf_, read_len_sandboxed), 0);
   }
 
  private:
@@ -1043,7 +1046,7 @@ class OpenFileRWDelegate final : public BrokerTestDelegate {
     len = HANDLE_EINTR(read(tempfile.fd(), buf, sizeof(buf)));
 
     BPF_ASSERT_EQ(len, static_cast<ssize_t>(sizeof(test_text)));
-    UNSAFE_TODO(BPF_ASSERT_EQ(memcmp(test_text, buf, sizeof(test_text)), 0));
+    BPF_ASSERT_EQ(memcmp(test_text, buf, sizeof(test_text)), 0);
 
     BPF_ASSERT_EQ(close(tempfile2), 0);
   }
@@ -1277,7 +1280,7 @@ class CreateFileDelegate final : public BrokerTestDelegate {
       char buf[1024];
       ssize_t len = HANDLE_EINTR(read(fd_check, buf, sizeof(buf)));
       BPF_ASSERT_EQ(len, static_cast<ssize_t>(sizeof(kTestText)));
-      UNSAFE_TODO(BPF_ASSERT_EQ(memcmp(kTestText, buf, sizeof(kTestText)), 0));
+      BPF_ASSERT_EQ(memcmp(kTestText, buf, sizeof(kTestText)), 0);
     }
   }
 
@@ -1306,7 +1309,7 @@ class StatFileDelegate : public BrokerTestDelegate {
  public:
   BrokerParams ChildSetUpPreSandbox() override {
     BPF_ASSERT_EQ(12, HANDLE_EINTR(write(tmp_file_.fd(), "blahblahblah", 12)));
-    UNSAFE_TODO(memset(&sb_, 0, sizeof(sb_)));
+    memset(&sb_, 0, sizeof(sb_));
     return BrokerParams();
   }
 
@@ -1865,8 +1868,7 @@ class ReadlinkFileWithPermissionsDelegate final : public ReadlinkTestDelegate {
     ssize_t retlen = syscaller->Readlink(newpath_.c_str(), readlink_buf_,
                                          sizeof(readlink_buf_));
     BPF_ASSERT(retlen == static_cast<ssize_t>(oldpath_.length()));
-    UNSAFE_TODO(
-        BPF_ASSERT_EQ(0, memcmp(oldpath_.c_str(), readlink_buf_, retlen)));
+    BPF_ASSERT_EQ(0, memcmp(oldpath_.c_str(), readlink_buf_, retlen));
   }
 };
 
@@ -2806,7 +2808,7 @@ class InotifyAddWatchSuccessDelegate final : public InotifyAddWatchDelegate {
     std::vector<char> buf(4096);
     BPF_ASSERT_GE(read(inotify_instance.get(), buf.data(), buf.size()), 0);
     struct inotify_event* event =
-        UNSAFE_TODO(reinterpret_cast<struct inotify_event*>(buf.data()));
+        reinterpret_cast<struct inotify_event*>(buf.data());
     BPF_ASSERT_EQ(event->wd, wd);
 
     // Removing the watch should succeed.
@@ -2862,8 +2864,7 @@ class BaseFilePathWatcherDelegate final : public InotifyAddWatchDelegate {
                                                     base::File::FLAG_READ |
                                                     base::File::FLAG_WRITE);
     char buf2[] = "a";
-    UNSAFE_TODO(BPF_ASSERT_EQ(temp_file_again.Write(0, buf2, sizeof(buf2)),
-                              sizeof(buf2)));
+    BPF_ASSERT_EQ(temp_file_again.Write(0, buf2, sizeof(buf2)), sizeof(buf2));
     temp_file_again.Flush();
     temp_file_again.Close();
     // Wait until we receive a notification about the file modification.
diff --git a/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc b/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc
index 3882967d4b98d993258056a48bc756d2d6c1cf6b..424f755250ed2ef20adee48a736deff6363f80e6 100644
--- a/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 // Note: any code in this file MUST be async-signal safe.
 
 #include "sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.h"
@@ -84,7 +89,7 @@ void WriteToStdErr(const char* error_message, size_t size) {
       break;
     }
     size -= ret;
-    UNSAFE_TODO(error_message += ret);
+    error_message += ret;
   }
 }
 
@@ -494,44 +499,35 @@ intptr_t SIGSYSSocketcallHandler(const struct arch_seccomp_data& args,
   uint64_t call = args.args[0];
   if (args.nr == __NR_socketcall && 0 < call && call <= kLastSocketcall) {
     const size_t real_args_arr_len =
-        UNSAFE_TODO(socketcall_args[call]).num_args +
-        UNSAFE_TODO(socketcall_args[call]).num_zeroes;
+        socketcall_args[call].num_args + socketcall_args[call].num_zeroes;
 // The length of this array is bounded by the entries in the array above,
 // but the compiler isn't smart enough to figure that out.
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wvla-extension"
     unsigned long real_args_arr[real_args_arr_len];
 #pragma clang diagnostic pop
-    UNSAFE_TODO(memcpy(real_args_arr,
-                       reinterpret_cast<unsigned long*>(args.args[1]),
-                       real_args_arr_len * sizeof(unsigned long)));
-    UNSAFE_TODO(
-        memset(real_args_arr + socketcall_args[call].num_args, 0,
-               socketcall_args[call].num_zeroes * sizeof(unsigned long)));
+    memcpy(real_args_arr, reinterpret_cast<unsigned long*>(args.args[1]),
+           real_args_arr_len * sizeof(unsigned long));
+    memset(real_args_arr + socketcall_args[call].num_args, 0,
+           socketcall_args[call].num_zeroes * sizeof(unsigned long));
     switch (real_args_arr_len) {
       case 2:
-        return syscall(UNSAFE_TODO(socketcall_args[call]).sysno,
-                       real_args_arr[0], UNSAFE_TODO(real_args_arr[1]));
+        return syscall(socketcall_args[call].sysno, real_args_arr[0],
+                       real_args_arr[1]);
       case 3:
-        return syscall(UNSAFE_TODO(socketcall_args[call]).sysno,
-                       real_args_arr[0], UNSAFE_TODO(real_args_arr[1]),
-                       UNSAFE_TODO(real_args_arr[2]));
+        return syscall(socketcall_args[call].sysno, real_args_arr[0],
+                       real_args_arr[1], real_args_arr[2]);
       case 4:
-        return syscall(UNSAFE_TODO(socketcall_args[call]).sysno,
-                       real_args_arr[0], UNSAFE_TODO(real_args_arr[1]),
-                       UNSAFE_TODO(real_args_arr[2]),
-                       UNSAFE_TODO(real_args_arr[3]));
+        return syscall(socketcall_args[call].sysno, real_args_arr[0],
+                       real_args_arr[1], real_args_arr[2], real_args_arr[3]);
       case 5:
-        return syscall(
-            UNSAFE_TODO(socketcall_args[call]).sysno, real_args_arr[0],
-            UNSAFE_TODO(real_args_arr[1]), UNSAFE_TODO(real_args_arr[2]),
-            UNSAFE_TODO(real_args_arr[3]), UNSAFE_TODO(real_args_arr[4]));
+        return syscall(socketcall_args[call].sysno, real_args_arr[0],
+                       real_args_arr[1], real_args_arr[2], real_args_arr[3],
+                       real_args_arr[4]);
       case 6:
-        return syscall(
-            UNSAFE_TODO(socketcall_args[call]).sysno, real_args_arr[0],
-            UNSAFE_TODO(real_args_arr[1]), UNSAFE_TODO(real_args_arr[2]),
-            UNSAFE_TODO(real_args_arr[3]), UNSAFE_TODO(real_args_arr[4]),
-            UNSAFE_TODO(real_args_arr[5]));
+        return syscall(socketcall_args[call].sysno, real_args_arr[0],
+                       real_args_arr[1], real_args_arr[2], real_args_arr[3],
+                       real_args_arr[4], real_args_arr[5]);
       default:
         break;
     }
diff --git a/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers_unittest.cc b/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers_unittest.cc
index 8b0eecafb17ec789ae6774add573d97d7584bec7..391d9ca6de8a90c3e2afd92a7aa6b07fe8bf0949 100644
--- a/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers_unittest.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers_unittest.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/40285824): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.h"
 
 #include <fcntl.h>
@@ -16,7 +21,6 @@
 #include <utility>
 
 #include "base/check_op.h"
-#include "base/compiler_specific.h"
 #include "base/files/file_util.h"
 #include "base/files/scoped_file.h"
 #include "base/strings/safe_sprintf.h"
@@ -184,8 +188,7 @@ int g_syscall_no;
 SANDBOX_EXPORT intptr_t
 SIGSYSDirectSocketSyscallHandler(const struct arch_seccomp_data& args, void*) {
   // Record syscall args.
-  UNSAFE_TODO(
-      memcpy(g_syscall_args, args.args, kNumArgsToCopy * sizeof(uint64_t)));
+  memcpy(g_syscall_args, args.args, kNumArgsToCopy * sizeof(uint64_t));
   g_syscall_no = args.nr;
   return kDirectSocketSyscallRetVal;
 }
@@ -236,8 +239,8 @@ void CheckArgsMatch(long current_socketcall,
   // If the args don't match, crash to fail the test.
   for (size_t i = 0; i < N; i++) {
     unsigned long rewritten_socketcall_arg =
-        *reinterpret_cast<unsigned long*>(&UNSAFE_TODO(g_syscall_args[i]));
-    UNSAFE_TODO(CHECK_EQ(rewritten_socketcall_arg, expected_args[i]))
+        *reinterpret_cast<unsigned long*>(&g_syscall_args[i]);
+    CHECK_EQ(rewritten_socketcall_arg, expected_args[i])
         << "Socketcall " << current_socketcall << " differs at argument " << i;
   }
 }
diff --git a/sandbox/linux/seccomp-bpf/sandbox_bpf.cc b/sandbox/linux/seccomp-bpf/sandbox_bpf.cc
index 8ad0ed3192ec5fb7893d85b2f465a2c4f8f0ba25..d34da5bfd9fb7dbfe760d5f1f7126bab35529079 100644
--- a/sandbox/linux/seccomp-bpf/sandbox_bpf.cc
+++ b/sandbox/linux/seccomp-bpf/sandbox_bpf.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/linux/seccomp-bpf/sandbox_bpf.h"
 
 #include <errno.h>
@@ -234,7 +239,7 @@ void SandboxBPF::InstallFilter(bool must_sync_threads, bool enable_ibpb) {
 #pragma clang diagnostic pop
   const struct sock_fprog prog = {static_cast<unsigned short>(program.size()),
                                   bpf};
-  UNSAFE_TODO(memcpy(bpf, &program[0], sizeof(bpf)));
+  memcpy(bpf, &program[0], sizeof(bpf));
   CodeGen::Program().swap(program);  // vector swap trick
 
   // Make an attempt to release memory that is no longer needed here, rather
diff --git a/sandbox/linux/seccomp-bpf/syscall_unittest.cc b/sandbox/linux/seccomp-bpf/syscall_unittest.cc
index 9f42360847627b058c94605281bd53e3257858a9..95da98c560554e73db9371c8715add988b88f0cf 100644
--- a/sandbox/linux/seccomp-bpf/syscall_unittest.cc
+++ b/sandbox/linux/seccomp-bpf/syscall_unittest.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/linux/seccomp-bpf/syscall.h"
 
 #include <asm/unistd.h>
@@ -17,7 +22,6 @@
 #include <array>
 #include <vector>
 
-#include "base/compiler_specific.h"
 #include "base/memory/page_size.h"
 #include "base/memory/raw_ptr.h"
 #include "base/posix/eintr_wrapper.h"
@@ -46,8 +50,7 @@ TEST(Syscall, InvalidCallReturnsENOSYS) {
 template <typename T>
 T LoadBehind(intptr_t ptr) {
   T ret;
-  UNSAFE_TODO(memcpy(&ret, reinterpret_cast<const void*>(ptr - sizeof(T)),
-                     sizeof(ret)));
+  memcpy(&ret, reinterpret_cast<const void*>(ptr - sizeof(T)), sizeof(ret));
   return ret;
 }
 
@@ -108,8 +111,7 @@ intptr_t CopySyscallArgsToAux(const struct arch_seccomp_data& args, void* aux) {
   std::vector<uint64_t>* const seen_syscall_args =
       static_cast<std::vector<uint64_t>*>(aux);
   BPF_ASSERT(std::size(args.args) == 6);
-  seen_syscall_args->assign(args.args,
-                            UNSAFE_TODO(args.args + std::size(args.args)));
+  seen_syscall_args->assign(args.args, args.args + std::size(args.args));
   return -ENOMEM;
 }
 
@@ -242,14 +244,14 @@ TEST(Syscall, ComplexSyscallSixArgs) {
                                                           )));
 #if !defined(MEMORY_SANITIZER)
   // MSan considers the memory backing addr2 uninitialized.
-  UNSAFE_TODO(EXPECT_EQ(0, memcmp(addr2 + kPageSize, addr3, kPageSize)));
+  EXPECT_EQ(0, memcmp(addr2 + kPageSize, addr3, kPageSize));
 
   // Just to be absolutely on the safe side, also verify that the file
   // contents matches what we are getting from a read() operation.
   base::FixedArray<char> buf(2 * kPageSize);
   EXPECT_EQ(2 * kPageSize, static_cast<size_t>(Syscall::Call(
                                __NR_read, fd, buf.data(), 2 * kPageSize)));
-  UNSAFE_TODO(EXPECT_EQ(0, memcmp(addr2, buf.data(), 2 * kPageSize)));
+  EXPECT_EQ(0, memcmp(addr2, buf.data(), 2 * kPageSize));
 #endif
 
   // Clean up
diff --git a/sandbox/linux/seccomp-bpf/trap.cc b/sandbox/linux/seccomp-bpf/trap.cc
index 1316786d73a8a37cfa2c956c0c23b9e0d0ae15b7..9fbefe3e8b7bc7ae71353d89690353de4d0fef2c 100644
--- a/sandbox/linux/seccomp-bpf/trap.cc
+++ b/sandbox/linux/seccomp-bpf/trap.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/linux/seccomp-bpf/trap.h"
 
 #include <errno.h>
@@ -226,7 +231,7 @@ void Trap::SigSys(int nr, LinuxSigInfo* info, ucontext_t* ctx) {
                        SECCOMP_PARM6(ctx));
 #endif  // defined(__mips__)
   } else {
-    const auto& trap = UNSAFE_TODO(trap_array_[info->si_errno - 1]);
+    const auto& trap = trap_array_[info->si_errno - 1];
     if (!trap.safe) {
       SetIsInSigHandler();
     }
@@ -333,7 +338,7 @@ uint16_t Trap::Add(const Handler& handler) {
 
   uint16_t id = trap_array_size_ + 1;
   trap_ids_[handler] = id;
-  UNSAFE_TODO(trap_array_[trap_array_size_]) = handler;
+  trap_array_[trap_array_size_] = handler;
   trap_array_size_++;
   return id;
 }
diff --git a/sandbox/linux/services/libc_interceptor.cc b/sandbox/linux/services/libc_interceptor.cc
index 18a6aee1151ea27f071fd482b34e46b577614d13..db1555f0c1780d7b5949264931f35c4e39204365 100644
--- a/sandbox/linux/services/libc_interceptor.cc
+++ b/sandbox/linux/services/libc_interceptor.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/linux/services/libc_interceptor.h"
 
 #include <dlfcn.h>
@@ -162,8 +167,8 @@ bool ReadTimeStruct(base::PickleIterator* iter,
     return false;
   if (timezone_out_len) {
     const size_t copy_len = std::min(timezone_out_len - 1, timezone.size());
-    UNSAFE_TODO(memcpy(timezone_out, timezone.data(), copy_len));
-    UNSAFE_TODO(timezone_out[copy_len]) = 0;
+    memcpy(timezone_out, timezone.data(), copy_len);
+    timezone_out[copy_len] = 0;
     output->tm_zone = timezone_out;
   } else {
     base::AutoLock lock(g_timezones_lock.Get());
@@ -199,7 +204,7 @@ void ProxyLocaltimeCallToBrowser(time_t input,
   request.WriteString(
       std::string(reinterpret_cast<char*>(&input), sizeof(input)));
 
-  UNSAFE_TODO(memset(output, 0, sizeof(struct tm)));
+  memset(output, 0, sizeof(struct tm));
 
   uint8_t reply_buf[512];
   const ssize_t r = base::UnixDomainSocket::SendRecvMsg(
@@ -208,10 +213,10 @@ void ProxyLocaltimeCallToBrowser(time_t input,
     return;
 
   base::Pickle reply = base::Pickle::WithUnownedBuffer(
-      UNSAFE_TODO(base::span(reply_buf, base::checked_cast<size_t>(r))));
+      base::span(reply_buf, base::checked_cast<size_t>(r)));
   base::PickleIterator iter(reply);
   if (!ReadTimeStruct(&iter, output, timezone_out, timezone_out_len)) {
-    UNSAFE_TODO(memset(output, 0, sizeof(struct tm)));
+    memset(output, 0, sizeof(struct tm));
   }
 }
 
@@ -224,7 +229,7 @@ bool HandleLocalTime(int fd,
     return false;
 
   time_t time;
-  UNSAFE_TODO(memcpy(&time, time_string.data(), sizeof(time)));
+  memcpy(&time, time_string.data(), sizeof(time));
   struct tm expanded_time = {};
   localtime_r(&time, &expanded_time);
 
@@ -232,7 +237,7 @@ bool HandleLocalTime(int fd,
   WriteTimeStruct(&reply, expanded_time);
 
   struct msghdr msg;
-  UNSAFE_TODO(memset(&msg, 0, sizeof(msg)));
+  memset(&msg, 0, sizeof(msg));
 
   struct iovec iov = {const_cast<uint8_t*>(reply.data()), reply.size()};
   msg.msg_iov = &iov;
diff --git a/sandbox/linux/services/syscall_wrappers.cc b/sandbox/linux/services/syscall_wrappers.cc
index b7f4349b5c16444b85ceec2ad1d54c9336c936ee..ecc897e27c63c9a204e422e793222f41d90940eb 100644
--- a/sandbox/linux/services/syscall_wrappers.cc
+++ b/sandbox/linux/services/syscall_wrappers.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
+#pragma allow_unsafe_libc_calls
+#endif
+
 #include "sandbox/linux/services/syscall_wrappers.h"
 
 #include <fcntl.h>
@@ -151,9 +156,9 @@ int sys_sigprocmask(int how, const sigset_t* set, std::nullptr_t oldset) {
   // In some toolchain (in particular Android and PNaCl toolchain),
   // sigset_t is 32 bits, but the Linux ABI uses more.
   LinuxSigSet linux_value;
-  UNSAFE_TODO(std::memset(&linux_value, 0, sizeof(LinuxSigSet)));
-  UNSAFE_TODO(std::memcpy(&linux_value, set,
-                          std::min(sizeof(sigset_t), sizeof(LinuxSigSet))));
+  std::memset(&linux_value, 0, sizeof(LinuxSigSet));
+  std::memcpy(&linux_value, set, std::min(sizeof(sigset_t),
+                                          sizeof(LinuxSigSet)));
 
   return syscall(__NR_rt_sigprocmask, how, &linux_value, nullptr,
                  sizeof(linux_value));
diff --git a/sandbox/linux/services/syscall_wrappers_unittest.cc b/sandbox/linux/services/syscall_wrappers_unittest.cc
index 41aaffbda9da5557f6fbe56d5aded5796906012f..0905089f35757f6a0e1cff8e9be67c6ea510dd86 100644
--- a/sandbox/linux/services/syscall_wrappers_unittest.cc
+++ b/sandbox/linux/services/syscall_wrappers_unittest.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/linux/services/syscall_wrappers.h"
 
 #include <fcntl.h>
@@ -12,7 +17,6 @@
 #include <sys/wait.h>
 #include <unistd.h>
 
-#include "base/compiler_specific.h"
 #include "base/logging.h"
 #include "base/memory/page_size.h"
 #include "base/posix/eintr_wrapper.h"
@@ -94,8 +98,8 @@ TEST(SyscallWrappers, LinuxSigSet) {
   ASSERT_EQ(0, sigaddset(&sigset, LINUX_SIGSEGV));
   ASSERT_EQ(0, sigaddset(&sigset, LINUX_SIGBUS));
   uint64_t linux_sigset = 0;
-  UNSAFE_TODO(std::memcpy(&linux_sigset, &sigset,
-                          std::min(sizeof(sigset), sizeof(linux_sigset))));
+  std::memcpy(&linux_sigset, &sigset,
+              std::min(sizeof(sigset), sizeof(linux_sigset)));
   EXPECT_EQ((1ULL << (LINUX_SIGSEGV - 1)) | (1ULL << (LINUX_SIGBUS - 1)),
             linux_sigset);
 }
@@ -109,13 +113,12 @@ TEST(SyscallWrappers, Stat) {
   // will right-align them on a page, with a guard page after.
   char* two_pages = static_cast<char*>(TestUtils::MapPagesOrDie(2));
   TestUtils::MprotectLastPageOrDie(two_pages, 2);
-  char* page1_end = UNSAFE_TODO(two_pages + base::GetPageSize());
+  char* page1_end = two_pages + base::GetPageSize();
 
   // First, check that calling stat with |stat_buf| pointing to the last byte on
   // a page causes EFAULT.
-  int res = sys_stat(
-      tmp_file.full_file_name(),
-      reinterpret_cast<struct kernel_stat*>(UNSAFE_TODO(page1_end - 1)));
+  int res = sys_stat(tmp_file.full_file_name(),
+                     reinterpret_cast<struct kernel_stat*>(page1_end - 1));
   ASSERT_EQ(res, -1);
   if (res < 0 && errno == EOVERFLOW) {
     GTEST_SKIP();
@@ -124,9 +127,9 @@ TEST(SyscallWrappers, Stat) {
 
   // Now, check that we have the correctly sized stat structure.
   struct kernel_stat* sb = reinterpret_cast<struct kernel_stat*>(
-      UNSAFE_TODO(page1_end - sizeof(struct kernel_stat)));
+      page1_end - sizeof(struct kernel_stat));
   // Memset to c's so we can check the kernel zero'd the padding...
-  UNSAFE_TODO(memset(sb, 'c', sizeof(struct kernel_stat)));
+  memset(sb, 'c', sizeof(struct kernel_stat));
   res = sys_stat(tmp_file.full_file_name(), sb);
   ASSERT_EQ(res, 0);
 
@@ -181,20 +184,20 @@ TEST(SyscallWrappers, Stat64) {
   // will right-align them on a page, with a guard page after.
   char* two_pages = static_cast<char*>(TestUtils::MapPagesOrDie(2));
   TestUtils::MprotectLastPageOrDie(two_pages, 2);
-  char* page1_end = UNSAFE_TODO(two_pages + base::GetPageSize());
+  char* page1_end = two_pages + base::GetPageSize();
 
   // First, check that calling stat with |stat_buf| pointing to the last byte on
   // a page causes EFAULT.
-  int res = sys_fstatat64(
-      AT_FDCWD, tmp_file.full_file_name(),
-      reinterpret_cast<struct kernel_stat64*>(UNSAFE_TODO(page1_end - 1)), 0);
+  int res =
+      sys_fstatat64(AT_FDCWD, tmp_file.full_file_name(),
+                    reinterpret_cast<struct kernel_stat64*>(page1_end - 1), 0);
   ASSERT_EQ(res, -1);
   ASSERT_EQ(errno, EFAULT);
 
   // Now, check that we have the correctly sized stat structure.
   struct kernel_stat64* sb = reinterpret_cast<struct kernel_stat64*>(
-      UNSAFE_TODO(page1_end - sizeof(struct kernel_stat64)));
-  UNSAFE_TODO(memset(sb, 0, sizeof(struct kernel_stat64)));
+      page1_end - sizeof(struct kernel_stat64));
+  memset(sb, 0, sizeof(struct kernel_stat64));
   res = sys_fstatat64(AT_FDCWD, tmp_file.full_file_name(), sb, 0);
   ASSERT_EQ(res, 0);
 
diff --git a/sandbox/linux/services/yama_unittest.cc b/sandbox/linux/services/yama_unittest.cc
index 5e8d5ad03a968267c4812feee6426516c4cea90e..d31710f1d6fd1f4e18a3dd88bbbd91a66ac02cb7 100644
--- a/sandbox/linux/services/yama_unittest.cc
+++ b/sandbox/linux/services/yama_unittest.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/390223051): Remove C-library calls to fix the errors.
+#pragma allow_unsafe_libc_calls
+#endif
+
 #include <errno.h>
 #include <fcntl.h>
 #include <sys/ptrace.h>
@@ -109,9 +114,8 @@ TEST(Yama, GetStatus) {
   EXPECT_EQ(static_cast<bool>(status1 & Yama::STATUS_PRESENT),
             Yama::IsPresent());
 
-  UNSAFE_TODO(fprintf(stdout, "Yama present: %s - enforcing: %s\n",
-                      Yama::IsPresent() ? "Y" : "N",
-                      Yama::IsEnforcing() ? "Y" : "N"));
+  fprintf(stdout, "Yama present: %s - enforcing: %s\n",
+          Yama::IsPresent() ? "Y" : "N", Yama::IsEnforcing() ? "Y" : "N");
 }
 
 SANDBOX_TEST(Yama, RestrictPtraceSucceedsWhenYamaPresent) {
diff --git a/sandbox/linux/syscall_broker/broker_client.cc b/sandbox/linux/syscall_broker/broker_client.cc
index 96174e78d9a94cfaa25038ae78f7b7c051b6bd41..848af1020ded70327a9927ab8723af9be985f593 100644
--- a/sandbox/linux/syscall_broker/broker_client.cc
+++ b/sandbox/linux/syscall_broker/broker_client.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/linux/syscall_broker/broker_client.h"
 
 #include <errno.h>
@@ -15,7 +20,6 @@
 #include <utility>
 
 #include "base/check.h"
-#include "base/compiler_specific.h"
 #include "build/build_config.h"
 #include "sandbox/linux/syscall_broker/broker_channel.h"
 #include "sandbox/linux/syscall_broker/broker_command.h"
@@ -117,7 +121,7 @@ int BrokerClient::Readlink(const char* path, char* buf, size_t bufsize) const {
   if (return_length > bufsize) {
     return_length = bufsize;
   }
-  UNSAFE_TODO(memcpy(buf, return_data, return_length));
+  memcpy(buf, return_data, return_length);
   return return_length;
 }
 
@@ -226,8 +230,7 @@ int BrokerClient::InotifyAddWatch(int fd,
 
   BrokerSimpleMessage reply;
   ssize_t msg_len = message.SendRecvMsgWithFlagsMultipleFds(
-      ipc_channel_.get(), 0, UNSAFE_TODO(base::span<const int>(&fd, 1u)), {},
-      &reply);
+      ipc_channel_.get(), 0, base::span<const int>(&fd, 1u), {}, &reply);
 
   if (msg_len < 0)
     return msg_len;
@@ -366,7 +369,7 @@ int BrokerClient::StatFamilySyscall(BrokerCommand syscall_type,
     return -ENOMEM;
   if (static_cast<size_t>(return_length) != expected_result_size)
     return -ENOMEM;
-  UNSAFE_TODO(memcpy(result_ptr, return_data, expected_result_size));
+  memcpy(result_ptr, return_data, expected_result_size);
   return return_value;
 }
 
diff --git a/sandbox/linux/syscall_broker/broker_host.cc b/sandbox/linux/syscall_broker/broker_host.cc
index 1ec857a6dcbb168219b7e5ae5f0c7bfe0c044466..bf1339b06112ac439599b6b1c31447f2ec8600ae 100644
--- a/sandbox/linux/syscall_broker/broker_host.cc
+++ b/sandbox/linux/syscall_broker/broker_host.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/linux/syscall_broker/broker_host.h"
 
 #include <errno.h>
@@ -20,7 +25,6 @@
 #include <tuple>
 #include <utility>
 
-#include "base/compiler_specific.h"
 #include "base/files/scoped_file.h"
 #include "base/logging.h"
 #include "base/posix/eintr_wrapper.h"
@@ -57,7 +61,7 @@ int sys_open(const char* pathname, int flags) {
 std::optional<std::string> BrokerHost::RewritePathname(const char* pathname) {
   if (base::StartsWith(pathname, kProcSelf)) {
     return base::StringPrintf("/proc/%d/%s", sandboxed_process_pid_,
-                              UNSAFE_TODO(pathname + kProcSelfNumChars));
+                              pathname + kProcSelfNumChars);
   }
 
   return std::nullopt;
diff --git a/sandbox/linux/syscall_broker/broker_process_unittest.cc b/sandbox/linux/syscall_broker/broker_process_unittest.cc
index 4b485f7ce595f41932b2b65c06e15dabd43af46d..9679b40acc6d247f360dc0ebef1bb9c51a0cea10 100644
--- a/sandbox/linux/syscall_broker/broker_process_unittest.cc
+++ b/sandbox/linux/syscall_broker/broker_process_unittest.cc
@@ -2,6 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/linux/syscall_broker/broker_process.h"
 
 #include <errno.h>
@@ -22,7 +28,6 @@
 #include <string_view>
 #include <vector>
 
-#include "base/compiler_specific.h"
 #include "base/containers/flat_map.h"
 #include "base/containers/flat_set.h"
 #include "base/containers/span.h"
@@ -404,7 +409,7 @@ void TestOpenCpuinfo(bool fast_check_in_client, bool recursive) {
     base::ScopedFD cpuinfo_fd_closer(cpuinfo_fd);
     EXPECT_GE(cpuinfo_fd, 0);
     char buf[3];
-    UNSAFE_TODO(memset(buf, 0, sizeof(buf)));
+    memset(buf, 0, sizeof(buf));
     int read_len1 = read(cpuinfo_fd, buf, sizeof(buf));
     EXPECT_GT(read_len1, 0);
 
@@ -413,7 +418,7 @@ void TestOpenCpuinfo(bool fast_check_in_client, bool recursive) {
     base::ScopedFD cpuinfo_fd2_closer(cpuinfo_fd2);
     EXPECT_GE(cpuinfo_fd2, 0);
     char buf2[3];
-    UNSAFE_TODO(memset(buf2, 1, sizeof(buf2)));
+    memset(buf2, 1, sizeof(buf2));
     int read_len2 = read(cpuinfo_fd2, buf2, sizeof(buf2));
     EXPECT_GT(read_len1, 0);
 
@@ -421,7 +426,7 @@ void TestOpenCpuinfo(bool fast_check_in_client, bool recursive) {
     EXPECT_EQ(read_len1, read_len2);
     // Compare the cpuinfo as returned by the broker with the one we opened
     // ourselves.
-    UNSAFE_TODO(EXPECT_EQ(memcmp(buf, buf2, read_len1), 0));
+    EXPECT_EQ(memcmp(buf, buf2, read_len1), 0);
 
     ASSERT_TRUE(TestUtils::CurrentProcessHasChildren());
   }
@@ -491,7 +496,7 @@ TEST(BrokerProcess, OpenFileRW) {
   len = read(tempfile.fd(), buf, sizeof(buf));
 
   ASSERT_EQ(len, static_cast<ssize_t>(sizeof(test_text)));
-  UNSAFE_TODO(ASSERT_EQ(memcmp(test_text, buf, sizeof(test_text)), 0));
+  ASSERT_EQ(memcmp(test_text, buf, sizeof(test_text)), 0);
 
   ASSERT_EQ(close(tempfile2), 0);
 }
@@ -880,7 +885,7 @@ TEST(BrokerProcess, CreateFile) {
     char buf[1024];
     ssize_t len = HANDLE_EINTR(read(fd_check, buf, sizeof(buf)));
     ASSERT_EQ(len, static_cast<ssize_t>(sizeof(kTestText)));
-    UNSAFE_TODO(ASSERT_EQ(memcmp(kTestText, buf, sizeof(kTestText)), 0));
+    ASSERT_EQ(memcmp(kTestText, buf, sizeof(kTestText)), 0);
   }
 
   // Cleanup.
@@ -918,7 +923,7 @@ void TestStatHelper(bool fast_check_in_client, bool follow_links) {
 
     ASSERT_TRUE(open_broker.Fork(base::BindOnce(&NoOpCallback)));
 
-    UNSAFE_TODO(memset(&sb, 0, sizeof(sb)));
+    memset(&sb, 0, sizeof(sb));
     EXPECT_EQ(-kFakeErrnoSentinel,
               open_broker.GetBrokerClientSignalBased()->DefaultStatForTesting(
                   tempfile_name, follow_links, &sb));
@@ -937,7 +942,7 @@ void TestStatHelper(bool fast_check_in_client, bool follow_links) {
 
     ASSERT_TRUE(open_broker.Fork(base::BindOnce(&NoOpCallback)));
 
-    UNSAFE_TODO(memset(&sb, 0, sizeof(sb)));
+    memset(&sb, 0, sizeof(sb));
     EXPECT_EQ(-kFakeErrnoSentinel,
               open_broker.GetBrokerClientSignalBased()->DefaultStatForTesting(
                   nonesuch_name, follow_links, &sb));
@@ -952,7 +957,7 @@ void TestStatHelper(bool fast_check_in_client, bool follow_links) {
 
     ASSERT_TRUE(open_broker.Fork(base::BindOnce(&NoOpCallback)));
 
-    UNSAFE_TODO(memset(&sb, 0, sizeof(sb)));
+    memset(&sb, 0, sizeof(sb));
     EXPECT_EQ(-kFakeErrnoSentinel,
               open_broker.GetBrokerClientSignalBased()->DefaultStatForTesting(
                   tempfile_name, follow_links, &sb));
@@ -968,7 +973,7 @@ void TestStatHelper(bool fast_check_in_client, bool follow_links) {
 
     ASSERT_TRUE(open_broker.Fork(base::BindOnce(&NoOpCallback)));
 
-    UNSAFE_TODO(memset(&sb, 0, sizeof(sb)));
+    memset(&sb, 0, sizeof(sb));
     EXPECT_EQ(-ENOENT,
               open_broker.GetBrokerClientSignalBased()->DefaultStatForTesting(
                   nonesuch_name, follow_links, &sb));
@@ -1015,7 +1020,7 @@ void TestStatHelper(bool fast_check_in_client, bool follow_links) {
 
     ASSERT_TRUE(open_broker.Fork(base::BindOnce(&NoOpCallback)));
 
-    UNSAFE_TODO(memset(&sb, 0, sizeof(sb)));
+    memset(&sb, 0, sizeof(sb));
     EXPECT_EQ(-ENOENT,
               open_broker.GetBrokerClientSignalBased()->DefaultStatForTesting(
                   nonesuch_name, follow_links, &sb));
@@ -1064,7 +1069,7 @@ void TestStatHelper(bool fast_check_in_client, bool follow_links) {
 
     ASSERT_TRUE(open_broker.Fork(base::BindOnce(&NoOpCallback)));
 
-    UNSAFE_TODO(memset(&sb, 0, sizeof(sb)));
+    memset(&sb, 0, sizeof(sb));
     EXPECT_EQ(0,
               open_broker.GetBrokerClientSignalBased()->DefaultStatForTesting(
                   tempfile_name, follow_links, &sb));
@@ -1334,7 +1339,7 @@ void TestReadlinkHelper(bool fast_check_in_client) {
     ssize_t retlen = open_broker.GetBrokerClientSignalBased()->Readlink(
         newpath_name, buf, sizeof(buf));
     EXPECT_TRUE(retlen == static_cast<ssize_t>(strlen(oldpath_name)));
-    UNSAFE_TODO(EXPECT_EQ(0, memcmp(oldpath_name, buf, retlen)));
+    EXPECT_EQ(0, memcmp(oldpath_name, buf, retlen));
   }
   {
     // Actual file with permissions to see file, but too small a buffer.
diff --git a/sandbox/win/src/address_sanitizer_test.cc b/sandbox/win/src/address_sanitizer_test.cc
index e36ac86a3fe38172c0265550c36d48e3ca197b5d..6d5b3c05e2c6d21f882fbd91281bcc80c2b8f05d 100644
--- a/sandbox/win/src/address_sanitizer_test.cc
+++ b/sandbox/win/src/address_sanitizer_test.cc
@@ -2,12 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include <stdio.h>
 
 #include <memory>
 #include <optional>
 
-#include "base/compiler_specific.h"
 #include "base/environment.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
@@ -45,7 +49,7 @@ SBOX_TESTS_COMMAND int AddressSanitizerTests_Report(int argc, wchar_t** argv) {
   // overflow) in this code.
   volatile int idx = 42;
   int* volatile blah = new int[42];
-  UNSAFE_TODO(blah[idx]) = 42;
+  blah[idx] = 42;
   delete[] blah;
   return SBOX_TEST_FAILED;
 }
@@ -93,19 +97,17 @@ TEST_F(AddressSanitizerTests, TestAddressSanitizer) {
     std::string data;
     ASSERT_TRUE(base::ReadFileToString(base::FilePath(temp_file_name), &data));
     // Redirection uses a feature that was added in Windows Vista.
-    ASSERT_TRUE(UNSAFE_TODO(
-        strstr(data.c_str(), "ERROR: AddressSanitizer: heap-buffer-overflow")))
+    ASSERT_TRUE(
+        strstr(data.c_str(), "ERROR: AddressSanitizer: heap-buffer-overflow"))
         << "There doesn't seem to be an ASan report:\n"
         << data;
-    ASSERT_TRUE(
-        UNSAFE_TODO(strstr(data.c_str(), "AddressSanitizerTests_Report")))
+    ASSERT_TRUE(strstr(data.c_str(), "AddressSanitizerTests_Report"))
         << "The ASan report doesn't appear to be symbolized:\n"
         << data;
     std::string source_file_basename(__FILE__);
     size_t last_slash = source_file_basename.find_last_of("/\\");
     last_slash = last_slash == std::string::npos ? 0 : last_slash + 1;
-    ASSERT_TRUE(
-        UNSAFE_TODO(strstr(data.c_str(), &source_file_basename[last_slash])))
+    ASSERT_TRUE(strstr(data.c_str(), &source_file_basename[last_slash]))
         << "The stack trace doesn't have a correct filename:\n"
         << data;
   } else {
diff --git a/sandbox/win/src/app_container_test.cc b/sandbox/win/src/app_container_test.cc
index 6f062db76ba433051ba19c47c2710a83e135a9c0..6f351c03d0faefbaefd7294e8b7456e14c52e6d4 100644
--- a/sandbox/win/src/app_container_test.cc
+++ b/sandbox/win/src/app_container_test.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include <windows.h>
 
 #include <memory>
@@ -9,7 +14,6 @@
 #include <vector>
 
 #include "base/command_line.h"
-#include "base/compiler_specific.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/format_macros.h"
@@ -81,12 +85,11 @@ void CheckToken(const std::optional<base::win::AccessToken>& token,
   ASSERT_EQ(capabilities.size(), security_capabilities->CapabilityCount)
       << TokenTypeToName(impersonation);
   for (size_t index = 0; index < capabilities.size(); ++index) {
-    EXPECT_EQ(
-        capabilities[index].GetAttributes(),
-        UNSAFE_TODO(security_capabilities->Capabilities[index]).Attributes)
+    EXPECT_EQ(capabilities[index].GetAttributes(),
+              security_capabilities->Capabilities[index].Attributes)
         << TokenTypeToName(impersonation);
     EXPECT_TRUE(capabilities[index].GetSid().Equal(
-        UNSAFE_TODO(security_capabilities->Capabilities[index]).Sid))
+        security_capabilities->Capabilities[index].Sid))
         << TokenTypeToName(impersonation);
   }
 }
diff --git a/sandbox/win/src/app_container_unittest.cc b/sandbox/win/src/app_container_unittest.cc
index 3508c8fab2475572fc0b99b906b331314d4acdb1..e1148076d38ad53576d6f3f99b2a3636816b1ef2 100644
--- a/sandbox/win/src/app_container_unittest.cc
+++ b/sandbox/win/src/app_container_unittest.cc
@@ -2,12 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include <windows.h>
 
 #include <string>
 #include <vector>
 
-#include "base/compiler_specific.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/files/scoped_temp_dir.h"
@@ -58,10 +62,10 @@ bool ValidSecurityCapabilities(
   for (DWORD index = 0; index < security_capabilities->CapabilityCount;
        ++index) {
     if (!capabilities[index].Equal(
-            UNSAFE_TODO(security_capabilities->Capabilities[index]).Sid)) {
+            security_capabilities->Capabilities[index].Sid)) {
       return false;
     }
-    if (UNSAFE_TODO(security_capabilities->Capabilities[index]).Attributes !=
+    if (security_capabilities->Capabilities[index].Attributes !=
         SE_GROUP_ENABLED) {
       return false;
     }
diff --git a/sandbox/win/src/crosscall_client.h b/sandbox/win/src/crosscall_client.h
index 81e56a93453ebd4f517aa45e3a73a9257369ac02..b65c8d630b6a44d4769e7d5de62a6d0b8d37dafd 100644
--- a/sandbox/win/src/crosscall_client.h
+++ b/sandbox/win/src/crosscall_client.h
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #ifndef SANDBOX_WIN_SRC_CROSSCALL_CLIENT_H_
 #define SANDBOX_WIN_SRC_CROSSCALL_CLIENT_H_
 
diff --git a/sandbox/win/src/crosscall_params.h b/sandbox/win/src/crosscall_params.h
index 2daeaeb3252f84d72377a976b4566893d253c7f9..4ee9a367ac7355c9e87c5fec92cf7b264044c5f9 100644
--- a/sandbox/win/src/crosscall_params.h
+++ b/sandbox/win/src/crosscall_params.h
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #ifndef SANDBOX_WIN_SRC_CROSSCALL_PARAMS_H_
 #define SANDBOX_WIN_SRC_CROSSCALL_PARAMS_H_
 
@@ -11,7 +16,6 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#include "base/compiler_specific.h"
 #include "base/memory/raw_ptr_exclusion.h"
 #include "sandbox/win/src/internal_types.h"
 #include "sandbox/win/src/ipc_tags.h"
@@ -51,10 +55,9 @@ inline uint32_t Align(uint32_t value) {
 }
 
 inline void* memcpy_wrapper(void* dest, const void* src, size_t count) {
-  if (UNSAFE_TODO(g_nt.memcpy)) {
-    return UNSAFE_TODO(g_nt.memcpy)(dest, src, count);
-  }
-  return UNSAFE_TODO(memcpy(dest, src, count));
+  if (g_nt.memcpy)
+    return g_nt.memcpy(dest, src, count);
+  return memcpy(dest, src, count);
 }
 
 }  // namespace
@@ -249,13 +252,12 @@ class ActualCallParams : public CrossCallParams {
     }
 
     if ((size > sizeof(*this)) ||
-        (UNSAFE_TODO(param_info_[index]).offset_ > (sizeof(*this) - size))) {
+        (param_info_[index].offset_ > (sizeof(*this) - size))) {
       // It does not fit, abort copy.
       return false;
     }
 
-    char* dest =
-        UNSAFE_TODO(reinterpret_cast<char*>(this) + param_info_[index].offset_);
+    char* dest = reinterpret_cast<char*>(this) + param_info_[index].offset_;
 
     // We might be touching user memory, this has to be done from inside a try
     // except.
@@ -270,17 +272,15 @@ class ActualCallParams : public CrossCallParams {
     if (is_in_out)
       SetIsInOut(true);
 
-    UNSAFE_TODO(param_info_[index + 1]).offset_ =
-        Align(UNSAFE_TODO(param_info_[index]).offset_ + size);
-    UNSAFE_TODO(param_info_[index]).size_ = size;
-    UNSAFE_TODO(param_info_[index]).type_ = type;
+    param_info_[index + 1].offset_ = Align(param_info_[index].offset_ + size);
+    param_info_[index].size_ = size;
+    param_info_[index].type_ = type;
     return true;
   }
 
   // Returns a pointer to a parameter in the memory section.
   void* GetParamPtr(size_t index) {
-    return UNSAFE_TODO(reinterpret_cast<char*>(this) +
-                       param_info_[index].offset_);
+    return reinterpret_cast<char*>(this) + param_info_[index].offset_;
   }
 
   // Returns the total size of the buffer. Only valid once all the paramters
diff --git a/sandbox/win/src/crosscall_server.cc b/sandbox/win/src/crosscall_server.cc
index 12d07c3ce4b6e7144b22875dc91db4ee71bc1035..a0fe698796e723ebcd2d0c82d18dc7cb6b5ef3c3 100644
--- a/sandbox/win/src/crosscall_server.cc
+++ b/sandbox/win/src/crosscall_server.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/crosscall_server.h"
 
 #include <stddef.h>
@@ -12,7 +17,6 @@
 #include <vector>
 
 #include "base/check.h"
-#include "base/compiler_specific.h"
 #include "base/strings/utf_string_conversions.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/crosscall_params.h"
@@ -157,7 +161,7 @@ CrossCallParamsEx* CrossCallParamsEx::CreateFromBuffer(void* buffer_base,
     *output_size = declared_size;
     backing_mem = new char[declared_size];
     copied_params = reinterpret_cast<CrossCallParamsEx*>(backing_mem);
-    UNSAFE_TODO(memcpy(backing_mem, call_params, declared_size));
+    memcpy(backing_mem, call_params, declared_size);
 
     // Avoid compiler optimizations across this point. Any value stored in
     // memory should be stored for real, and values previously read from memory
@@ -185,10 +189,9 @@ CrossCallParamsEx* CrossCallParamsEx::CreateFromBuffer(void* buffer_base,
   // Here and below we're making use of uintptr_t to have well-defined integer
   // overflow when doing pointer arithmetic.
   auto backing_mem_ptr = reinterpret_cast<uintptr_t>(backing_mem);
-  auto last_byte =
-      reinterpret_cast<uintptr_t>(&UNSAFE_TODO(backing_mem[declared_size]));
+  auto last_byte = reinterpret_cast<uintptr_t>(&backing_mem[declared_size]);
   auto first_byte =
-      reinterpret_cast<uintptr_t>(&UNSAFE_TODO(backing_mem[min_declared_size]));
+      reinterpret_cast<uintptr_t>(&backing_mem[min_declared_size]);
 
   // Verify here that all and each parameters make sense. This is done in the
   // local copy.
@@ -221,11 +224,10 @@ void* CrossCallParamsEx::GetRawParameter(uint32_t index,
     return nullptr;
   // The size is always computed from the parameter minus the next
   // parameter, this works because the message has an extra parameter slot
-  *size = UNSAFE_TODO(param_info_[index]).size_;
-  *type = UNSAFE_TODO(param_info_[index]).type_;
+  *size = param_info_[index].size_;
+  *type = param_info_[index].type_;
 
-  return UNSAFE_TODO(param_info_[index].offset_ +
-                     reinterpret_cast<char*>(this));
+  return param_info_[index].offset_ + reinterpret_cast<char*>(this);
 }
 
 // Covers common case for 32 bit integers.
diff --git a/sandbox/win/src/eat_resolver.cc b/sandbox/win/src/eat_resolver.cc
index adfae7e1f7357af5cc48509c9ab3c5a2f57436b8..b590fd8793f1e1e37eac146664bd123327d8b655 100644
--- a/sandbox/win/src/eat_resolver.cc
+++ b/sandbox/win/src/eat_resolver.cc
@@ -2,12 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/eat_resolver.h"
 
 #include <ntstatus.h>
 #include <stddef.h>
 
-#include "base/compiler_specific.h"
 #include "base/win/pe_image.h"
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
@@ -38,8 +42,7 @@ NTSTATUS EatResolverThunk::Setup(const void* target_module,
 
   size_t thunk_bytes = GetInternalThunkSize();
   storage_bytes -= thunk_bytes;
-  thunk_storage =
-      UNSAFE_TODO(reinterpret_cast<char*>(thunk_storage) + thunk_bytes);
+  thunk_storage = reinterpret_cast<char*>(thunk_storage) + thunk_bytes;
 #endif
 
   if (!SetInternalThunk(thunk_storage, storage_bytes, target_, interceptor_))
diff --git a/sandbox/win/src/file_policy_test.cc b/sandbox/win/src/file_policy_test.cc
index a52b3a06e75d7cde9b4654d21503112227970884..dfd88dba62fe9f36eec85af09eff7a5a0d22af6b 100644
--- a/sandbox/win/src/file_policy_test.cc
+++ b/sandbox/win/src/file_policy_test.cc
@@ -2,15 +2,19 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include <windows.h>
-#include <winternl.h>
 
 #include <ntstatus.h>
 #include <winioctl.h>
+#include <winternl.h>
 
 #include <algorithm>
 
-#include "base/compiler_specific.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/string_number_conversions_win.h"
 #include "base/strings/string_util_win.h"
@@ -48,12 +52,10 @@ SBOX_TESTS_COMMAND int File_Create(int argc, wchar_t** argv) {
   std::wstring operation(argv[0]);
 
   if (operation == L"Read") {
-    base::win::ScopedHandle file1(CreateFile(UNSAFE_TODO(argv[1]), GENERIC_READ,
-                                             kSharing, nullptr, OPEN_EXISTING,
-                                             0, nullptr));
-    base::win::ScopedHandle file2(CreateFile(UNSAFE_TODO(argv[1]), FILE_EXECUTE,
-                                             kSharing, nullptr, OPEN_EXISTING,
-                                             0, nullptr));
+    base::win::ScopedHandle file1(CreateFile(
+        argv[1], GENERIC_READ, kSharing, nullptr, OPEN_EXISTING, 0, nullptr));
+    base::win::ScopedHandle file2(CreateFile(
+        argv[1], FILE_EXECUTE, kSharing, nullptr, OPEN_EXISTING, 0, nullptr));
 
     if (file1.is_valid() == file2.is_valid()) {
       return file1.is_valid() ? SBOX_TEST_SUCCEEDED : SBOX_TEST_DENIED;
@@ -61,12 +63,12 @@ SBOX_TESTS_COMMAND int File_Create(int argc, wchar_t** argv) {
     return file1.is_valid() ? SBOX_TEST_FIRST_ERROR : SBOX_TEST_SECOND_ERROR;
 
   } else if (operation == L"Write") {
-    base::win::ScopedHandle file1(CreateFile(
-        UNSAFE_TODO(argv[1]), GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
-        kSharing, nullptr, OPEN_EXISTING, 0, nullptr));
-    base::win::ScopedHandle file2(
-        CreateFile(UNSAFE_TODO(argv[1]), GENERIC_READ | FILE_WRITE_DATA,
+    base::win::ScopedHandle file1(
+        CreateFile(argv[1], GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                    kSharing, nullptr, OPEN_EXISTING, 0, nullptr));
+    base::win::ScopedHandle file2(
+        CreateFile(argv[1], GENERIC_READ | FILE_WRITE_DATA, kSharing, nullptr,
+                   OPEN_EXISTING, 0, nullptr));
 
     if (file1.is_valid() == file2.is_valid()) {
       return file1.is_valid() ? SBOX_TEST_SUCCEEDED : SBOX_TEST_DENIED;
@@ -74,12 +76,10 @@ SBOX_TESTS_COMMAND int File_Create(int argc, wchar_t** argv) {
     return file1.is_valid() ? SBOX_TEST_FIRST_ERROR : SBOX_TEST_SECOND_ERROR;
 
   } else if (operation == L"ReadCreate") {
-    base::win::ScopedHandle file2(CreateFile(UNSAFE_TODO(argv[1]), GENERIC_READ,
-                                             kSharing, nullptr, CREATE_NEW, 0,
-                                             nullptr));
-    base::win::ScopedHandle file1(CreateFile(UNSAFE_TODO(argv[1]), GENERIC_READ,
-                                             kSharing, nullptr, CREATE_ALWAYS,
-                                             0, nullptr));
+    base::win::ScopedHandle file2(CreateFile(argv[1], GENERIC_READ, kSharing,
+                                             nullptr, CREATE_NEW, 0, nullptr));
+    base::win::ScopedHandle file1(CreateFile(
+        argv[1], GENERIC_READ, kSharing, nullptr, CREATE_ALWAYS, 0, nullptr));
 
     if (file1.is_valid() == file2.is_valid()) {
       return file1.is_valid() ? SBOX_TEST_SUCCEEDED : SBOX_TEST_DENIED;
@@ -138,7 +138,7 @@ SBOX_TESTS_COMMAND int File_CreateSys32(int argc, wchar_t** argv) {
                              OBJ_CASE_INSENSITIVE, nullptr, nullptr);
 
   unsigned options = 0;
-  if (argc == 2 && !base::StringToUint(UNSAFE_TODO(argv[1]), &options)) {
+  if (argc == 2 && !base::StringToUint(argv[1], &options)) {
     return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
   }
 
@@ -179,7 +179,7 @@ SBOX_TESTS_COMMAND int File_OpenSys32(int argc, wchar_t** argv) {
                              OBJ_CASE_INSENSITIVE, nullptr, nullptr);
 
   unsigned options = 0;
-  if (argc == 2 && !base::StringToUint(UNSAFE_TODO(argv[1]), &options)) {
+  if (argc == 2 && !base::StringToUint(argv[1], &options)) {
     return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
   }
 
@@ -227,9 +227,8 @@ SBOX_TESTS_COMMAND int File_Rename(int argc, wchar_t** argv) {
   if (argc != 2)
     return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
 
-  if (::MoveFileEx(argv[0], UNSAFE_TODO(argv[1]), 0)) {
+  if (::MoveFileEx(argv[0], argv[1], 0))
     return SBOX_TEST_SUCCEEDED;
-  }
 
   if (::GetLastError() != ERROR_ACCESS_DENIED)
     return SBOX_TEST_FAILED;
@@ -252,7 +251,7 @@ SBOX_TESTS_COMMAND int File_QueryAttributes(int argc, wchar_t** argv) {
   if (argc != 2)
     return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
 
-  bool expect_directory = (L'd' == UNSAFE_TODO(argv[1])[0]);
+  bool expect_directory = (L'd' == argv[1][0]);
 
   UNICODE_STRING object_name;
   std::wstring file = MakePathToSys(argv[0], true);
@@ -424,7 +423,7 @@ TEST(FilePolicyTest, AllowWildcard) {
   ASSERT_NE(::GetTempPath(MAX_PATH, temp_directory), 0u);
   ASSERT_NE(::GetTempFileName(temp_directory, L"test", 0, temp_file_name), 0u);
 
-  UNSAFE_TODO(wcscat_s(temp_directory, MAX_PATH, L"*"));
+  wcscat_s(temp_directory, MAX_PATH, L"*");
   EXPECT_TRUE(runner.AllowFileAccess(FileSemantics::kAllowAny, temp_directory));
 
   wchar_t command_write[MAX_PATH + 20] = {};
diff --git a/sandbox/win/src/filesystem_interception.cc b/sandbox/win/src/filesystem_interception.cc
index 078e5fa12abfed437ebd5f4b8ce29581833f5d26..35eb45adeaf109196aed05fbf8b9a32b6e49b74c 100644
--- a/sandbox/win/src/filesystem_interception.cc
+++ b/sandbox/win/src/filesystem_interception.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/filesystem_interception.h"
 
 #include <ntstatus.h>
diff --git a/sandbox/win/src/handle_closer_test.cc b/sandbox/win/src/handle_closer_test.cc
index 6ff30b2d1b8cd47a126c4b4d2965ee9797e944c9..cb747e2c04b3dc220b94df9fbda8ebfbd9280478 100644
--- a/sandbox/win/src/handle_closer_test.cc
+++ b/sandbox/win/src/handle_closer_test.cc
@@ -2,10 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include <limits.h>
 #include <stddef.h>
 
-#include "base/compiler_specific.h"
 #include "base/strings/string_util.h"
 #include "base/win/scoped_handle.h"
 #include "sandbox/win/src/handle_closer_agent.h"
@@ -60,8 +64,7 @@ SBOX_TESTS_COMMAND int CheckForFileHandles(int argc, wchar_t** argv) {
     return SBOX_TEST_FAILED_TO_RUN_TEST;
   }
   bool should_find = argv[0][0] == L'Y';
-  if (UNSAFE_TODO(argv[0][1]) != L'\0' ||
-      (!should_find && argv[0][0] != L'N')) {
+  if (argv[0][1] != L'\0' || (!should_find && argv[0][0] != L'N')) {
     return SBOX_TEST_FAILED_TO_RUN_TEST;
   }
 
@@ -91,7 +94,7 @@ SBOX_TESTS_COMMAND int CheckForFileHandles(int argc, wchar_t** argv) {
         auto handle_name = GetPathFromHandle(handle);
         if (handle_name) {
           for (int i = 1; i < argc; ++i) {
-            if (handle_name.value() == UNSAFE_TODO(argv[i])) {
+            if (handle_name.value() == argv[i]) {
               return should_find ? SBOX_TEST_SUCCEEDED : SBOX_TEST_FAILED;
             }
           }
@@ -202,12 +205,12 @@ SBOX_TESTS_COMMAND int RunThreadPool(int argc, wchar_t** argv) {
     CHECK(event);
     CHECK(::RegisterWaitForSingleObject(&pool, event, ThreadPoolTask, event,
                                         INFINITE, WT_EXECUTEONLYONCE));
-    UNSAFE_TODO(wait_list[i]) = event;
+    wait_list[i] = event;
   }
 
   // Signal all the waiters.
   for (int i = 0; i < kWaitCount; ++i)
-    CHECK(::SetEvent(UNSAFE_TODO(wait_list[i])));
+    CHECK(::SetEvent(wait_list[i]));
 
   CHECK_EQ(::WaitForSingleObject(finish_event, INFINITE), WAIT_OBJECT_0);
   CHECK(::CloseHandle(finish_event));
diff --git a/sandbox/win/src/interception.cc b/sandbox/win/src/interception.cc
index 82893663e3101a7f31e9704b75a1af6305dc2b6e..6af0ac99113189d8fe7eedc03924ae1e6ea0c961 100644
--- a/sandbox/win/src/interception.cc
+++ b/sandbox/win/src/interception.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 // For information about interceptions as a whole see
 // http://dev.chromium.org/developers/design-documents/sandbox .
 
@@ -15,7 +20,6 @@
 
 #include "base/bits.h"
 #include "base/check_op.h"
-#include "base/compiler_specific.h"
 #include "base/containers/heap_array.h"
 #include "base/notreached.h"
 #include "base/rand_util.h"
@@ -267,7 +271,7 @@ bool InterceptionManager::SetupDllInfo(const InterceptionData& data,
     return false;
 
   *buffer_bytes -= required;
-  *buffer = UNSAFE_TODO(reinterpret_cast<char*>(*buffer) + required);
+  *buffer = reinterpret_cast<char*>(*buffer) + required;
 
   // set up the dll info to be what we know about it at this time
   dll_info->unload_module = (data.type == INTERCEPTION_UNLOAD_MODULE);
@@ -275,7 +279,7 @@ bool InterceptionManager::SetupDllInfo(const InterceptionData& data,
   dll_info->offset_to_functions = required;
   dll_info->num_functions = 0;
   data.dll.copy(dll_info->dll_name, data.dll.size());
-  UNSAFE_TODO(dll_info->dll_name[data.dll.size()]) = L'\0';
+  dll_info->dll_name[data.dll.size()] = L'\0';
 
   return true;
 }
@@ -307,7 +311,7 @@ bool InterceptionManager::SetupInterceptionInfo(const InterceptionData& data,
 
   // update the caller's values
   *buffer_bytes -= required;
-  *buffer = UNSAFE_TODO(reinterpret_cast<char*>(*buffer) + required);
+  *buffer = reinterpret_cast<char*>(*buffer) + required;
 
   function->record_bytes = required;
   function->type = data.type;
@@ -316,13 +320,13 @@ bool InterceptionManager::SetupInterceptionInfo(const InterceptionData& data,
   char* names = function->function;
 
   data.function.copy(names, name_bytes);
-  UNSAFE_TODO(names += name_bytes);
-  *UNSAFE_TODO(names++) = '\0';
+  names += name_bytes;
+  *names++ = '\0';
 
   // interceptor follows the function_name
   data.interceptor.copy(names, interceptor_bytes);
-  UNSAFE_TODO(names += interceptor_bytes);
-  *UNSAFE_TODO(names++) = '\0';
+  names += interceptor_bytes;
+  *names++ = '\0';
 
   // update the dll table
   dll_info->num_functions++;
@@ -371,7 +375,7 @@ ResultCode InterceptionManager::PatchNtdll(bool hot_patch_needed) {
   size_t thunk_offset = internal::GetGranularAlignedRandomOffset(thunk_bytes);
 
   // Split the base and offset along page boundaries.
-  UNSAFE_TODO(thunk_base += thunk_offset & ~(kPageSize - 1));
+  thunk_base += thunk_offset & ~(kPageSize - 1);
   thunk_offset &= kPageSize - 1;
 
   // Make an aligned, padded allocation, and move the pointer to our chunk.
@@ -380,8 +384,8 @@ ResultCode InterceptionManager::PatchNtdll(bool hot_patch_needed) {
       ::VirtualAllocEx(child, thunk_base, thunk_bytes_padded, MEM_COMMIT,
                        PAGE_EXECUTE_READWRITE));
   CHECK(thunk_base);  // If this fails we'd crash anyway on an invalid access.
-  DllInterceptionData* thunks = reinterpret_cast<DllInterceptionData*>(
-      UNSAFE_TODO(thunk_base + thunk_offset));
+  DllInterceptionData* thunks =
+      reinterpret_cast<DllInterceptionData*>(thunk_base + thunk_offset);
 
   // this should write all the individual thunks to the child's memory
   base::expected<PatchClientResultData, ResultCode> patch =
@@ -439,16 +443,16 @@ InterceptionManager::PatchClientFunctions(DllInterceptionData* thunks,
     NTSTATUS ret = thunk.Setup(
         ntdll_base, nullptr, interception.function.c_str(),
         interception.interceptor.c_str(), interception.interceptor_address,
-        &UNSAFE_TODO(thunks->thunks[patch.dll_data.num_thunks]),
+        &thunks->thunks[patch.dll_data.num_thunks],
         thunk_bytes - patch.dll_data.used_bytes, nullptr);
     if (!NT_SUCCESS(ret)) {
       ::SetLastError(GetLastErrorFromNtStatus(ret));
       return base::unexpected(SBOX_ERROR_CANNOT_SETUP_INTERCEPTION_THUNK);
     }
 
-    DCHECK(!UNSAFE_TODO(patch.originals.functions[interception.id]));
-    UNSAFE_TODO(patch.originals.functions[interception.id]) =
-        &UNSAFE_TODO(thunks->thunks[patch.dll_data.num_thunks]);
+    DCHECK(!patch.originals.functions[interception.id]);
+    patch.originals.functions[interception.id] =
+        &thunks->thunks[patch.dll_data.num_thunks];
 
     patch.dll_data.num_thunks++;
     patch.dll_data.used_bytes += sizeof(ThunkData);
diff --git a/sandbox/win/src/interception_unittest.cc b/sandbox/win/src/interception_unittest.cc
index ca53a530291d73b8ec594450922d146caed30057..208330f6f2509af8968ad545f9d9dc450dd74045 100644
--- a/sandbox/win/src/interception_unittest.cc
+++ b/sandbox/win/src/interception_unittest.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 // This file contains unit tests for InterceptionManager.
 // The tests require private information so the whole interception.cc file is
 // included from this file.
@@ -16,7 +21,6 @@
 #include <bit>
 #include <set>
 
-#include "base/compiler_specific.h"
 #include "base/containers/heap_array.h"
 #include "sandbox/win/src/interception_internal.h"
 #include "sandbox/win/src/interceptors.h"
@@ -56,7 +60,7 @@ void WalkBuffer(base::span<BYTE> buffer,
     ASSERT_NE(0u, dll->num_functions);
 
     FunctionInfo* function = reinterpret_cast<FunctionInfo*>(
-        UNSAFE_TODO(reinterpret_cast<char*>(dll) + dll->offset_to_functions));
+        reinterpret_cast<char*>(dll) + dll->offset_to_functions);
 
     for (size_t j = 0; j < dll->num_functions; j++) {
       ASSERT_EQ(0u, function->record_bytes % sizeof(size_t));
@@ -64,12 +68,11 @@ void WalkBuffer(base::span<BYTE> buffer,
       char* name = function->function;
       size_t length = strlen(name);
       ASSERT_NE(0u, length);
-      UNSAFE_TODO(name += length + 1);
+      name += length + 1;
 
       // look for overflows
-      ASSERT_GT(
-          UNSAFE_TODO(reinterpret_cast<char*>(buffer.data()) + buffer.size()),
-          UNSAFE_TODO(name + strlen(name)));
+      ASSERT_GT(reinterpret_cast<char*>(buffer.data()) + buffer.size(),
+                name + strlen(name));
 
       // look for a named interceptor
       if (strlen(name)) {
@@ -80,13 +83,13 @@ void WalkBuffer(base::span<BYTE> buffer,
       }
 
       (*num_functions)++;
-      function = reinterpret_cast<FunctionInfo*>(UNSAFE_TODO(
-          reinterpret_cast<char*>(function) + function->record_bytes));
+      function = reinterpret_cast<FunctionInfo*>(
+          reinterpret_cast<char*>(function) + function->record_bytes);
     }
 
     (*num_dlls)++;
-    dll = reinterpret_cast<DllPatchInfo*>(
-        UNSAFE_TODO(reinterpret_cast<char*>(dll) + dll->record_bytes));
+    dll = reinterpret_cast<DllPatchInfo*>(reinterpret_cast<char*>(dll) +
+                                          dll->record_bytes);
   }
 }
 
diff --git a/sandbox/win/src/ipc_args.cc b/sandbox/win/src/ipc_args.cc
index 65e0f8dd5646fe5b9c6a28702f43eab39318f611..d6f667eb3c3c1d326aebed329a3e3390ca4cfa1b 100644
--- a/sandbox/win/src/ipc_args.cc
+++ b/sandbox/win/src/ipc_args.cc
@@ -2,11 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/ipc_args.h"
 
 #include <stddef.h>
 
-#include "base/compiler_specific.h"
 #include "sandbox/win/src/crosscall_params.h"
 #include "sandbox/win/src/crosscall_server.h"
 
@@ -15,15 +19,15 @@ namespace sandbox {
 // Releases memory allocated for IPC arguments, if needed.
 void ReleaseArgs(const IPCParams* ipc_params, void* args[kMaxIpcParams]) {
   for (size_t i = 0; i < kMaxIpcParams; i++) {
-    switch (UNSAFE_TODO(ipc_params->args[i])) {
+    switch (ipc_params->args[i]) {
       case WCHAR_TYPE: {
-        delete reinterpret_cast<std::wstring*>(UNSAFE_TODO(args[i]));
-        UNSAFE_TODO(args[i]) = nullptr;
+        delete reinterpret_cast<std::wstring*>(args[i]);
+        args[i] = nullptr;
         break;
       }
       case INOUTPTR_TYPE: {
-        delete reinterpret_cast<CountedBuffer*>(UNSAFE_TODO(args[i]));
-        UNSAFE_TODO(args[i]) = nullptr;
+        delete reinterpret_cast<CountedBuffer*>(args[i]);
+        args[i] = nullptr;
         break;
       }
       default:
@@ -42,18 +46,18 @@ bool GetArgs(CrossCallParamsEx* params,
   for (uint32_t i = 0; i < params->GetParamsCount(); i++) {
     uint32_t size;
     ArgType type;
-    UNSAFE_TODO(args[i]) = params->GetRawParameter(i, &size, &type);
-    if (UNSAFE_TODO(args[i])) {
-      UNSAFE_TODO(ipc_params->args[i]) = type;
+    args[i] = params->GetRawParameter(i, &size, &type);
+    if (args[i]) {
+      ipc_params->args[i] = type;
       switch (type) {
         case WCHAR_TYPE: {
           std::unique_ptr<std::wstring> data(new std::wstring);
           if (!params->GetParameterStr(i, data.get())) {
-            UNSAFE_TODO(args[i]) = 0;
+            args[i] = 0;
             ReleaseArgs(ipc_params, args);
             return false;
           }
-          UNSAFE_TODO(args[i]) = data.release();
+          args[i] = data.release();
           break;
         }
         case UINT32_TYPE: {
@@ -63,7 +67,7 @@ bool GetArgs(CrossCallParamsEx* params,
             return false;
           }
           IPCInt ipc_int(data);
-          UNSAFE_TODO(args[i]) = ipc_int.AsVoidPtr();
+          args[i] = ipc_int.AsVoidPtr();
           break;
         }
         case VOIDPTR_TYPE: {
@@ -72,16 +76,16 @@ bool GetArgs(CrossCallParamsEx* params,
             ReleaseArgs(ipc_params, args);
             return false;
           }
-          UNSAFE_TODO(args[i]) = data;
+          args[i] = data;
           break;
         }
         case INOUTPTR_TYPE: {
-          if (!UNSAFE_TODO(args[i])) {
+          if (!args[i]) {
             ReleaseArgs(ipc_params, args);
             return false;
           }
-          CountedBuffer* buffer = new CountedBuffer(UNSAFE_TODO(args[i]), size);
-          UNSAFE_TODO(args[i]) = buffer;
+          CountedBuffer* buffer = new CountedBuffer(args[i], size);
+          args[i] = buffer;
           break;
         }
         default:
diff --git a/sandbox/win/src/ipc_leak_test.cc b/sandbox/win/src/ipc_leak_test.cc
index c3a472de24ea3458e1cbe25fa074fe0aa363da6d..0e9efed61d6d9949e09d97cd2d8a922acc36c160 100644
--- a/sandbox/win/src/ipc_leak_test.cc
+++ b/sandbox/win/src/ipc_leak_test.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include <windows.h>
 #include <winternl.h>
 
@@ -10,7 +15,6 @@
 
 #include <memory>
 
-#include "base/compiler_specific.h"
 #include "base/memory/page_size.h"
 #include "base/win/windows_handle_util.h"
 #include "sandbox/win/src/crosscall_client.h"
@@ -42,7 +46,7 @@ PolicyGlobal* MakePolicyMemory() {
   // Should not exceed kPolMemSize from |sandbox_policy_base.cc|.
   const size_t kTotalPolicySz = 4096 * 6;
   char* mem = new char[kTotalPolicySz];
-  UNSAFE_TODO(memset(mem, 0, kTotalPolicySz));
+  memset(mem, 0, kTotalPolicySz);
   PolicyGlobal* policy = reinterpret_cast<PolicyGlobal*>(mem);
   policy->data_size = kTotalPolicySz - sizeof(PolicyGlobal);
   return policy;
@@ -151,18 +155,17 @@ PolicyGlobal* GenerateBlankPolicy() {
 void CopyPolicyToTarget(const void* source, size_t size, void* dest) {
   if (!source || !size)
     return;
-  UNSAFE_TODO(memcpy(dest, source, size));
+  memcpy(dest, source, size);
   sandbox::PolicyGlobal* policy =
       reinterpret_cast<sandbox::PolicyGlobal*>(dest);
 
   size_t offset = reinterpret_cast<size_t>(source);
 
   for (size_t i = 0; i < kSandboxIpcCount; i++) {
-    size_t buffer = reinterpret_cast<size_t>(UNSAFE_TODO(policy->entry[i]));
+    size_t buffer = reinterpret_cast<size_t>(policy->entry[i]);
     if (buffer) {
       buffer -= offset;
-      UNSAFE_TODO(policy->entry[i]) =
-          reinterpret_cast<sandbox::PolicyBuffer*>(buffer);
+      policy->entry[i] = reinterpret_cast<sandbox::PolicyBuffer*>(buffer);
     }
   }
 }
@@ -181,7 +184,7 @@ SBOX_TESTS_COMMAND int IPC_Leak(int argc, wchar_t** argv) {
   CopyPolicyToTarget(policy, policy->data_size + sizeof(PolicyGlobal),
                      current_policy);
 
-  int test = UNSAFE_TODO(wcstol(argv[0], nullptr, 10));
+  int test = wcstol(argv[0], nullptr, 10);
 
   static_assert(TESTIPC_NTOPENFILE == 0,
                 "TESTIPC_NTOPENFILE must be first in enum.");
@@ -225,7 +228,7 @@ SBOX_TESTS_COMMAND int IPC_Leak(int argc, wchar_t** argv) {
   };
 
   auto* ipc_data = reinterpret_cast<ipc_internal*>(
-      UNSAFE_TODO(reinterpret_cast<char*>(memory) + base_start));
+      reinterpret_cast<char*>(memory) + base_start);
 
   return base::win::HandleToUint32(ipc_data->answer.handle);
 }
diff --git a/sandbox/win/src/ipc_unittest.cc b/sandbox/win/src/ipc_unittest.cc
index 4db62ce9e035ef4642ee1bdfe5a2a9e30200c662..16dcbaa0ae75d3128a913f06d6d897da29d8f9d2 100644
--- a/sandbox/win/src/ipc_unittest.cc
+++ b/sandbox/win/src/ipc_unittest.cc
@@ -2,10 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include <stddef.h>
 #include <stdint.h>
 
-#include "base/compiler_specific.h"
 #include "base/memory/raw_ptr_exclusion.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/crosscall_server.h"
@@ -22,7 +26,7 @@ IPCControl* MakeChannels(size_t channel_size,
                          size_t* base_start) {
   // Allocate memory
   char* mem = new char[total_shared_size];
-  UNSAFE_TODO(memset(mem, 0, total_shared_size));
+  memset(mem, 0, total_shared_size);
   // Calculate how many channels we can fit in the shared memory.
   total_shared_size -= offsetof(IPCControl, channels);
   size_t channel_count =
@@ -43,7 +47,7 @@ void FixChannels(IPCControl* client_control,
                  size_t channel_size,
                  TestFixMode mode) {
   for (size_t ix = 0; ix != client_control->channels_count; ++ix) {
-    ChannelControl& channel = UNSAFE_TODO(client_control->channels[ix]);
+    ChannelControl& channel = client_control->channels[ix];
     channel.channel_base = base_start;
     channel.state = kFreeChannel;
     if (mode != FIX_NO_EVENTS) {
@@ -57,7 +61,7 @@ void FixChannels(IPCControl* client_control,
 
 void CloseChannelEvents(IPCControl* client_control) {
   for (size_t ix = 0; ix != client_control->channels_count; ++ix) {
-    ChannelControl& channel = UNSAFE_TODO(client_control->channels[ix]);
+    ChannelControl& channel = client_control->channels[ix];
     ::CloseHandle(channel.ping_event);
     ::CloseHandle(channel.pong_event);
   }
@@ -92,61 +96,57 @@ TEST(IPCTest, ClientLockUnlock) {
 
   // Test that we lock the first 3 channels in sequence.
   void* buff0 = client.GetBuffer();
-  EXPECT_TRUE(
-      UNSAFE_TODO(mem + client_control->channels[0].channel_base == buff0));
+  EXPECT_TRUE(mem + client_control->channels[0].channel_base == buff0);
   EXPECT_EQ(kBusyChannel, client_control->channels[0].state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[1]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[2]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[3]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[4]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[5]).state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[1].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[2].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[3].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[4].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[5].state);
 
   void* buff1 = client.GetBuffer();
-  EXPECT_TRUE(
-      UNSAFE_TODO(mem + client_control->channels[1].channel_base == buff1));
+  EXPECT_TRUE(mem + client_control->channels[1].channel_base == buff1);
   EXPECT_EQ(kBusyChannel, client_control->channels[0].state);
-  EXPECT_EQ(kBusyChannel, UNSAFE_TODO(client_control->channels[1]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[2]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[3]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[4]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[5]).state);
+  EXPECT_EQ(kBusyChannel, client_control->channels[1].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[2].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[3].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[4].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[5].state);
 
   void* buff2 = client.GetBuffer();
-  EXPECT_TRUE(
-      UNSAFE_TODO(mem + client_control->channels[2].channel_base == buff2));
+  EXPECT_TRUE(mem + client_control->channels[2].channel_base == buff2);
   EXPECT_EQ(kBusyChannel, client_control->channels[0].state);
-  EXPECT_EQ(kBusyChannel, UNSAFE_TODO(client_control->channels[1]).state);
-  EXPECT_EQ(kBusyChannel, UNSAFE_TODO(client_control->channels[2]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[3]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[4]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[5]).state);
+  EXPECT_EQ(kBusyChannel, client_control->channels[1].state);
+  EXPECT_EQ(kBusyChannel, client_control->channels[2].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[3].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[4].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[5].state);
 
   // Test that we unlock and re-lock the right channel.
   client.FreeBuffer(buff1);
   EXPECT_EQ(kBusyChannel, client_control->channels[0].state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[1]).state);
-  EXPECT_EQ(kBusyChannel, UNSAFE_TODO(client_control->channels[2]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[3]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[4]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[5]).state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[1].state);
+  EXPECT_EQ(kBusyChannel, client_control->channels[2].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[3].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[4].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[5].state);
 
   void* buff2b = client.GetBuffer();
-  EXPECT_TRUE(
-      UNSAFE_TODO(mem + client_control->channels[1].channel_base == buff2b));
+  EXPECT_TRUE(mem + client_control->channels[1].channel_base == buff2b);
   EXPECT_EQ(kBusyChannel, client_control->channels[0].state);
-  EXPECT_EQ(kBusyChannel, UNSAFE_TODO(client_control->channels[1]).state);
-  EXPECT_EQ(kBusyChannel, UNSAFE_TODO(client_control->channels[2]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[3]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[4]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[5]).state);
+  EXPECT_EQ(kBusyChannel, client_control->channels[1].state);
+  EXPECT_EQ(kBusyChannel, client_control->channels[2].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[3].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[4].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[5].state);
 
   client.FreeBuffer(buff0);
   EXPECT_EQ(kFreeChannel, client_control->channels[0].state);
-  EXPECT_EQ(kBusyChannel, UNSAFE_TODO(client_control->channels[1]).state);
-  EXPECT_EQ(kBusyChannel, UNSAFE_TODO(client_control->channels[2]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[3]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[4]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[5]).state);
+  EXPECT_EQ(kBusyChannel, client_control->channels[1].state);
+  EXPECT_EQ(kBusyChannel, client_control->channels[2].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[3].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[4].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[5].state);
 
   delete[] reinterpret_cast<char*>(client_control);
 }
@@ -263,7 +263,7 @@ TEST(IPCTest, CrossCallIntPacking) {
   ASSERT_EQ(sizeof(dw), param_size);
   EXPECT_EQ(UINT32_TYPE, type);
   ASSERT_TRUE(param_addr);
-  EXPECT_EQ(0, UNSAFE_TODO(memcmp(&dw, param_addr, param_size)));
+  EXPECT_EQ(0, memcmp(&dw, param_addr, param_size));
 
   // Check handling for windows HANDLES.
   HANDLE h = HANDLE(0x70000500);
@@ -276,7 +276,7 @@ TEST(IPCTest, CrossCallIntPacking) {
   ASSERT_EQ(sizeof(h), param_size);
   EXPECT_EQ(VOIDPTR_TYPE, type);
   ASSERT_TRUE(param_addr);
-  EXPECT_EQ(0, UNSAFE_TODO(memcmp(&h, param_addr, param_size)));
+  EXPECT_EQ(0, memcmp(&h, param_addr, param_size));
 
   // Check combination of 32 and 64 bits.
   CrossCall(client, tag2, h, dw, h, &answer);
@@ -288,19 +288,19 @@ TEST(IPCTest, CrossCallIntPacking) {
   ASSERT_EQ(sizeof(h), param_size);
   EXPECT_EQ(VOIDPTR_TYPE, type);
   ASSERT_TRUE(param_addr);
-  EXPECT_EQ(0, UNSAFE_TODO(memcmp(&h, param_addr, param_size)));
+  EXPECT_EQ(0, memcmp(&h, param_addr, param_size));
   type = INVALID_TYPE;
   param_addr = actual_params->GetRawParameter(1, &param_size, &type);
   ASSERT_EQ(sizeof(dw), param_size);
   EXPECT_EQ(UINT32_TYPE, type);
   ASSERT_TRUE(param_addr);
-  EXPECT_EQ(0, UNSAFE_TODO(memcmp(&dw, param_addr, param_size)));
+  EXPECT_EQ(0, memcmp(&dw, param_addr, param_size));
   type = INVALID_TYPE;
   param_addr = actual_params->GetRawParameter(2, &param_size, &type);
   ASSERT_EQ(sizeof(h), param_size);
   EXPECT_EQ(VOIDPTR_TYPE, type);
   ASSERT_TRUE(param_addr);
-  EXPECT_EQ(0, UNSAFE_TODO(memcmp(&h, param_addr, param_size)));
+  EXPECT_EQ(0, memcmp(&h, param_addr, param_size));
 
   CloseChannelEvents(client_control);
   delete[] reinterpret_cast<char*>(client_control);
@@ -425,9 +425,9 @@ TEST(IPCTest, ClientFastServer) {
   SharedMemIPCClient client(mem);
 
   ServerEvents events = {0};
-  events.ping = UNSAFE_TODO(client_control->channels[1]).ping_event;
-  events.pong = UNSAFE_TODO(client_control->channels[1]).pong_event;
-  events.state = &UNSAFE_TODO(client_control->channels[1]).state;
+  events.ping = client_control->channels[1].ping_event;
+  events.pong = client_control->channels[1].pong_event;
+  events.state = &client_control->channels[1].state;
 
   HANDLE t1 =
       ::CreateThread(nullptr, 0, QuickResponseServer, &events, 0, nullptr);
@@ -435,20 +435,18 @@ TEST(IPCTest, ClientFastServer) {
   ::CloseHandle(t1);
 
   void* buff0 = client.GetBuffer();
-  EXPECT_TRUE(
-      UNSAFE_TODO(mem + client_control->channels[0].channel_base == buff0));
+  EXPECT_TRUE(mem + client_control->channels[0].channel_base == buff0);
   EXPECT_EQ(kBusyChannel, client_control->channels[0].state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[1]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[2]).state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[1].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[2].state);
 
   void* buff1 = client.GetBuffer();
-  EXPECT_TRUE(
-      UNSAFE_TODO(mem + client_control->channels[1].channel_base == buff1));
+  EXPECT_TRUE(mem + client_control->channels[1].channel_base == buff1);
   EXPECT_EQ(kBusyChannel, client_control->channels[0].state);
-  EXPECT_EQ(kBusyChannel, UNSAFE_TODO(client_control->channels[1]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[2]).state);
+  EXPECT_EQ(kBusyChannel, client_control->channels[1].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[2].state);
 
-  EXPECT_EQ(IpcTag::UNUSED, UNSAFE_TODO(client_control->channels[1]).ipc_tag);
+  EXPECT_EQ(IpcTag::UNUSED, client_control->channels[1].ipc_tag);
 
   IpcTag tag = IpcTag::PING1;
   CrossCallReturn answer;
@@ -460,10 +458,10 @@ TEST(IPCTest, ClientFastServer) {
     client.FreeBuffer(buff1);
 
   EXPECT_TRUE(SBOX_ALL_OK == result);
-  EXPECT_EQ(tag, UNSAFE_TODO(client_control->channels[1]).ipc_tag);
+  EXPECT_EQ(tag, client_control->channels[1].ipc_tag);
   EXPECT_EQ(kBusyChannel, client_control->channels[0].state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[1]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[2]).state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[1].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[2].state);
 
   HANDLE t2 =
       ::CreateThread(nullptr, 0, QuickResponseServer, &events, 0, nullptr);
@@ -486,8 +484,8 @@ TEST(IPCTest, ClientFastServer) {
   EXPECT_TRUE(SBOX_ALL_OK == result);
   EXPECT_EQ(tag, client_control->channels[0].ipc_tag);
   EXPECT_EQ(kFreeChannel, client_control->channels[0].state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[1]).state);
-  EXPECT_EQ(kFreeChannel, UNSAFE_TODO(client_control->channels[2]).state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[1].state);
+  EXPECT_EQ(kFreeChannel, client_control->channels[2].state);
 
   CloseChannelEvents(client_control);
   ::CloseHandle(client_control->server_alive);
diff --git a/sandbox/win/src/policy_engine_opcodes.cc b/sandbox/win/src/policy_engine_opcodes.cc
index b5d0231723325778aec23c23e5124410c72212b0..a2a3efdfa783ba89a7a25940f22f96e720e65126 100644
--- a/sandbox/win/src/policy_engine_opcodes.cc
+++ b/sandbox/win/src/policy_engine_opcodes.cc
@@ -2,13 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/policy_engine_opcodes.h"
 
 #include <stddef.h>
 #include <stdint.h>
 
 #include "base/check_op.h"
-#include "base/compiler_specific.h"
 #include "sandbox/win/src/sandbox_nt_types.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
 #include "sandbox/win/src/sandbox_types.h"
@@ -309,7 +313,7 @@ PolicyOpcode* OpcodeFactory::MakeBase(OpcodeID opcode_id, uint32_t options) {
   PolicyOpcode* opcode = new (memory_top_) PolicyOpcode();
 
   // Fill in the standard fields, that every opcode has.
-  UNSAFE_TODO(memory_top_ += sizeof(PolicyOpcode));
+  memory_top_ += sizeof(PolicyOpcode);
   opcode->opcode_id_ = opcode_id;
   opcode->SetOptions(options);
   opcode->has_param_ = 0;
@@ -332,12 +336,12 @@ ptrdiff_t OpcodeFactory::AllocRelative(void* start, std::wstring_view str) {
   size_t bytes = str.size() * sizeof(wchar_t);
   if (memory_size() < bytes)
     return 0;
-  UNSAFE_TODO(memory_bottom_ -= bytes);
+  memory_bottom_ -= bytes;
   if (reinterpret_cast<UINT_PTR>(memory_bottom_.get()) & 1) {
     // TODO(cpu) replace this for something better.
     ::DebugBreak();
   }
-  UNSAFE_TODO(memcpy(memory_bottom_, str.data(), bytes));
+  memcpy(memory_bottom_, str.data(), bytes);
   ptrdiff_t delta = memory_bottom_ - reinterpret_cast<char*>(start);
   return delta;
 }
@@ -362,7 +366,7 @@ EvalResult PolicyOpcode::Evaluate(const ParameterSet* call_params,
     if (parameter_ >= param_count) {
       return EVAL_ERROR;
     }
-    selected_param = &UNSAFE_TODO(call_params[parameter_]);
+    selected_param = &call_params[parameter_];
   }
   EvalResult result = EvaluateHelper(selected_param, match);
 
diff --git a/sandbox/win/src/policy_engine_opcodes.h b/sandbox/win/src/policy_engine_opcodes.h
index 8eb45012e9a3cd4c9d57cbc98ba611843533e92d..cd9a819818c7b0488105df93b7ba300835591ded 100644
--- a/sandbox/win/src/policy_engine_opcodes.h
+++ b/sandbox/win/src/policy_engine_opcodes.h
@@ -2,13 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #ifndef SANDBOX_WIN_SRC_POLICY_ENGINE_OPCODES_H_
 #define SANDBOX_WIN_SRC_POLICY_ENGINE_OPCODES_H_
 
 #include <stddef.h>
 #include <stdint.h>
 
-#include "base/compiler_specific.h"
 #include "base/memory/raw_ptr.h"
 #include "base/numerics/safe_conversions.h"
 #include "sandbox/win/src/policy_engine_params.h"
@@ -153,8 +157,7 @@ class PolicyOpcode {
   template <typename T>
   void GetArgument(size_t index, T* argument) const {
     static_assert(sizeof(T) <= sizeof(arguments_[0]), "invalid size");
-    *argument =
-        *reinterpret_cast<const T*>(&UNSAFE_TODO(arguments_[index]).mem);
+    *argument = *reinterpret_cast<const T*>(&arguments_[index].mem);
   }
 
   // Sets a stored argument by index. Valid index values are
@@ -162,7 +165,7 @@ class PolicyOpcode {
   template <typename T>
   void SetArgument(size_t index, const T& argument) {
     static_assert(sizeof(T) <= sizeof(arguments_[0]), "invalid size");
-    *reinterpret_cast<T*>(&UNSAFE_TODO(arguments_[index]).mem) = argument;
+    *reinterpret_cast<T*>(&arguments_[index].mem) = argument;
   }
 
   // Retrieves the actual address of a string argument. When using
@@ -173,8 +176,7 @@ class PolicyOpcode {
   const wchar_t* GetRelativeString(size_t index) const {
     ptrdiff_t str_delta = 0;
     GetArgument(index, &str_delta);
-    const char* delta =
-        UNSAFE_TODO(reinterpret_cast<const char*>(this) + str_delta);
+    const char* delta = reinterpret_cast<const char*>(this) + str_delta;
     return reinterpret_cast<const wchar_t*>(delta);
   }
 
@@ -265,14 +267,14 @@ class OpcodeFactory {
   // memory: base pointer to a chunk of memory where the opcodes are created.
   // memory_size: the size in bytes of the memory chunk.
   OpcodeFactory(char* memory, size_t memory_size) : memory_top_(memory) {
-    memory_bottom_ = &UNSAFE_TODO(memory_top_[memory_size]);
+    memory_bottom_ = &memory_top_[memory_size];
   }
 
   // policy: contains the raw memory where the opcodes are created.
   // memory_size: contains the actual size of the policy argument.
   OpcodeFactory(PolicyBuffer* policy, size_t memory_size) {
     memory_top_ = reinterpret_cast<char*>(&policy->opcodes[0]);
-    memory_bottom_ = &UNSAFE_TODO(memory_top_[memory_size]);
+    memory_bottom_ = &memory_top_[memory_size];
   }
 
   OpcodeFactory(const OpcodeFactory&) = delete;
diff --git a/sandbox/win/src/policy_engine_params.h b/sandbox/win/src/policy_engine_params.h
index 991e5bfd21963268057820a8f9c5e2d4d8b938b7..bc23d9a63396a347a0eb6a14af2d204d300d5eb5 100644
--- a/sandbox/win/src/policy_engine_params.h
+++ b/sandbox/win/src/policy_engine_params.h
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #ifndef SANDBOX_WIN_SRC_POLICY_ENGINE_PARAMS_H_
 #define SANDBOX_WIN_SRC_POLICY_ENGINE_PARAMS_H_
 
@@ -9,7 +14,6 @@
 
 #include <string_view>
 
-#include "base/compiler_specific.h"
 #include "base/memory/raw_ptr.h"
 #include "sandbox/win/src/internal_types.h"
 #include "sandbox/win/src/nt_internals.h"
@@ -171,9 +175,7 @@ template <typename T>
 struct CountedParameterSet {
   CountedParameterSet() : count(T::PolParamLast) {}
 
-  ParameterSet& operator[](typename T::Args n) {
-    return UNSAFE_TODO(parameters[n]);
-  }
+  ParameterSet& operator[](typename T::Args n) { return parameters[n]; }
 
   CountedParameterSetBase* GetBase() {
     return reinterpret_cast<CountedParameterSetBase*>(this);
diff --git a/sandbox/win/src/policy_engine_processor.cc b/sandbox/win/src/policy_engine_processor.cc
index b14f08540fb35e96c515a4ecaaa19ba434aca855..1c2b8b305552ceeff25428ada285b3d7aa95f05c 100644
--- a/sandbox/win/src/policy_engine_processor.cc
+++ b/sandbox/win/src/policy_engine_processor.cc
@@ -2,13 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/policy_engine_processor.h"
 
 #include <stddef.h>
 #include <stdint.h>
 
-#include "base/compiler_specific.h"
-
 namespace sandbox {
 
 void PolicyProcessor::SetInternalState(size_t index, EvalResult result) {
@@ -64,7 +67,7 @@ PolicyResult PolicyProcessor::Evaluate(uint32_t options,
   // after the action depending on kPolUseOREval.
 
   for (size_t ix = 0; ix != count; ++ix) {
-    PolicyOpcode& opcode = UNSAFE_TODO(policy_->opcodes[ix]);
+    PolicyOpcode& opcode = policy_->opcodes[ix];
     // Skipping block.
     if (skip_group) {
       if (SkipOpcode(opcode, &context, &skip_group))
diff --git a/sandbox/win/src/policy_low_level.cc b/sandbox/win/src/policy_low_level.cc
index fef88d68e4ad7757127da69ab7b326e5c1f4228e..fce6bf893e104039371fa2969de6c008f2b0cd16 100644
--- a/sandbox/win/src/policy_low_level.cc
+++ b/sandbox/win/src/policy_low_level.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/policy_low_level.h"
 
 #include <stddef.h>
@@ -77,8 +82,8 @@ bool LowLevelPolicy::Done() {
   }
 
   PolicyBuffer* current_buffer = &policy_store_->data[0];
-  char* buffer_end = UNSAFE_TODO(reinterpret_cast<char*>(current_buffer) +
-                                 policy_store_->data_size);
+  char* buffer_end =
+      reinterpret_cast<char*>(current_buffer) + policy_store_->data_size;
   size_t avail_size = policy_store_->data_size;
 
   for (Mmap::iterator it = mmap.begin(); it != mmap.end(); ++it) {
@@ -86,8 +91,7 @@ bool LowLevelPolicy::Done() {
     if (service > IpcTag::kMaxValue) {
       return false;
     }
-    UNSAFE_TODO(policy_store_->entry[static_cast<size_t>(service)]) =
-        current_buffer;
+    policy_store_->entry[static_cast<size_t>(service)] = current_buffer;
 
     RuleList::iterator rules_it = (*it).second.begin();
     RuleList::iterator rules_it_end = (*it).second.end();
@@ -103,14 +107,13 @@ bool LowLevelPolicy::Done() {
         return false;
       }
       size_t data_size = avail_size - opcodes_size;
-      PolicyOpcode* opcodes_start =
-          &UNSAFE_TODO(current_buffer->opcodes[svc_opcode_count]);
+      PolicyOpcode* opcodes_start = &current_buffer->opcodes[svc_opcode_count];
       if (!rule->RebindCopy(opcodes_start, opcodes_size, buffer_end,
                             &data_size)) {
         return false;
       }
       size_t used = avail_size - data_size;
-      UNSAFE_TODO(buffer_end -= used);
+      buffer_end -= used;
       avail_size -= used;
       svc_opcode_count += op_count;
     }
@@ -118,7 +121,7 @@ bool LowLevelPolicy::Done() {
     current_buffer->opcode_count = svc_opcode_count;
     size_t policy_buffers_occupied =
         (svc_opcode_count * sizeof(PolicyOpcode)) / sizeof(current_buffer[0]);
-    current_buffer = &UNSAFE_TODO(current_buffer[policy_buffers_occupied + 1]);
+    current_buffer = &current_buffer[policy_buffers_occupied + 1];
   }
 
   return true;
@@ -140,11 +143,10 @@ PolicyRule::PolicyRule(const PolicyRule& other) {
   size_t buffer_size = sizeof(PolicyBuffer) + kRuleBufferSize;
   char* memory = new char[buffer_size];
   buffer_ = reinterpret_cast<PolicyBuffer*>(memory);
-  UNSAFE_TODO(memcpy(buffer_, other.buffer_, buffer_size));
+  memcpy(buffer_, other.buffer_, buffer_size);
 
   char* opcode_buffer = reinterpret_cast<char*>(&buffer_->opcodes[0]);
-  char* next_opcode =
-      &UNSAFE_TODO(opcode_buffer[GetOpcodeCount() * sizeof(PolicyOpcode)]);
+  char* next_opcode = &opcode_buffer[GetOpcodeCount() * sizeof(PolicyOpcode)];
   opcode_factory_ =
       new OpcodeFactory(next_opcode, other.opcode_factory_->memory_size());
 }
@@ -187,7 +189,7 @@ bool PolicyRule::GenStringOpcode(RuleType rule_type,
     // the previous opcode because it was really the last but we did not know
     // it at that time.
     if (last_call && (buffer_->opcode_count > 0)) {
-      op = &UNSAFE_TODO(buffer_->opcodes[buffer_->opcode_count - 1]);
+      op = &buffer_->opcodes[buffer_->opcode_count - 1];
       op->SetOptions(options);
     }
     return true;
@@ -242,13 +244,13 @@ bool PolicyRule::AddStringMatch(RuleType rule_type,
         break;
       case L'/':
         // Check that someone isn't using the old syntax.
-        CHECK(L'?' != UNSAFE_TODO(current_char[1]));
+        CHECK(L'?' != current_char[1]);
         [[fallthrough]];
       default:
         fragment += *current_char;
         last_char = kLastCharIsAlpha;
     }
-    UNSAFE_TODO(++current_char);
+    ++current_char;
   }
 
   return GenStringOpcode(rule_type, parameter, state, true, &skip_count,
@@ -296,7 +298,7 @@ bool PolicyRule::RebindCopy(PolicyOpcode* opcode_start,
     if (opcode_size < sizeof(PolicyOpcode)) {
       return false;
     }
-    PolicyOpcode& opcode = UNSAFE_TODO(buffer_->opcodes[ix]);
+    PolicyOpcode& opcode = buffer_->opcodes[ix];
     *opcode_start = opcode;
     if (OP_WSTRING_MATCH == opcode.GetID()) {
       // For this opcode argument 0 is a delta to the string and argument 1
@@ -309,13 +311,13 @@ bool PolicyRule::RebindCopy(PolicyOpcode* opcode_start,
         return false;
       }
       *data_size -= str_len;
-      UNSAFE_TODO(data_start -= str_len);
-      UNSAFE_TODO(memcpy(data_start, str, str_len));
+      data_start -= str_len;
+      memcpy(data_start, str, str_len);
       // Recompute the string displacement
       ptrdiff_t delta = data_start - reinterpret_cast<char*>(opcode_start);
       opcode_start->SetArgument(0, delta);
     }
-    UNSAFE_TODO(++opcode_start);
+    ++opcode_start;
     opcode_size -= sizeof(PolicyOpcode);
   }
 
diff --git a/sandbox/win/src/policy_low_level.h b/sandbox/win/src/policy_low_level.h
index 86d98aa839137697ee5e10c571803c105f9b1791..c2be454355af4c5594e662bee511eb17f737e99f 100644
--- a/sandbox/win/src/policy_low_level.h
+++ b/sandbox/win/src/policy_low_level.h
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #ifndef SANDBOX_WIN_SRC_POLICY_LOW_LEVEL_H_
 #define SANDBOX_WIN_SRC_POLICY_LOW_LEVEL_H_
 
@@ -9,9 +14,9 @@
 #include <stdint.h>
 
 #include <list>
+
 #include <string>
 
-#include "base/compiler_specific.h"
 #include "base/memory/raw_ptr.h"
 #include "sandbox/win/src/ipc_tags.h"
 #include "sandbox/win/src/policy_engine_opcodes.h"
@@ -72,7 +77,7 @@ struct PolicyGlobal {
   // Returns true if the IPC for `service` should be registered for the target.
   // Should only be called after Done() has been called to finalize the setup.
   bool NeedsIpc(IpcTag service) {
-    return UNSAFE_TODO(entry[static_cast<size_t>(service)]) != nullptr;
+    return entry[static_cast<size_t>(service)] != nullptr;
   }
 
   PolicyBuffer* entry[kSandboxIpcCount];
diff --git a/sandbox/win/src/policy_low_level_unittest.cc b/sandbox/win/src/policy_low_level_unittest.cc
index 59536417c1b762ef577eefeba115bf8b5157fe2f..844e5fd085e7dcc507cd8255922cb1281550482a 100644
--- a/sandbox/win/src/policy_low_level_unittest.cc
+++ b/sandbox/win/src/policy_low_level_unittest.cc
@@ -2,12 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/policy_low_level.h"
 
 #include <stddef.h>
 #include <stdint.h>
 
-#include "base/compiler_specific.h"
 #include "sandbox/win/src/policy_engine_params.h"
 #include "sandbox/win/src/policy_engine_processor.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -39,7 +43,7 @@ TEST(PolicyEngineTest, StringPatternsBAD) {
 PolicyGlobal* MakePolicyMemory() {
   const size_t kTotalPolicySz = 4096 * 8;
   char* mem = new char[kTotalPolicySz];
-  UNSAFE_TODO(memset(mem, 0, kTotalPolicySz));
+  memset(mem, 0, kTotalPolicySz);
   PolicyGlobal* policy = reinterpret_cast<PolicyGlobal*>(mem);
   policy->data_size = kTotalPolicySz - sizeof(PolicyGlobal);
   return policy;
@@ -380,25 +384,22 @@ TEST(PolicyEngineTest, ThreeRulesTest) {
   EXPECT_EQ(
       OP_NUMBER_AND_MATCH,
       policy->entry[static_cast<size_t>(kNtFakeNone)]->opcodes[0].GetID());
-  EXPECT_EQ(OP_ACTION,
-            UNSAFE_TODO(policy->entry[static_cast<size_t>(kNtFakeNone)])
-                ->opcodes[tc1 - 1]
-                .GetID());
+  EXPECT_EQ(OP_ACTION, policy->entry[static_cast<size_t>(kNtFakeNone)]
+                           ->opcodes[tc1 - 1]
+                           .GetID());
   EXPECT_EQ(OP_WSTRING_MATCH,
             policy->entry[static_cast<size_t>(kNtFakeCreateFile)]
                 ->opcodes[0]
                 .GetID());
-  EXPECT_EQ(OP_ACTION,
-            UNSAFE_TODO(policy->entry[static_cast<size_t>(kNtFakeCreateFile)])
-                ->opcodes[tc2 - 1]
-                .GetID());
+  EXPECT_EQ(OP_ACTION, policy->entry[static_cast<size_t>(kNtFakeCreateFile)]
+                           ->opcodes[tc2 - 1]
+                           .GetID());
   EXPECT_EQ(
       OP_WSTRING_MATCH,
       policy->entry[static_cast<size_t>(kNtFakeOpenFile)]->opcodes[0].GetID());
-  EXPECT_EQ(OP_ACTION,
-            UNSAFE_TODO(policy->entry[static_cast<size_t>(kNtFakeOpenFile)])
-                ->opcodes[tc3 - 1]
-                .GetID());
+  EXPECT_EQ(OP_ACTION, policy->entry[static_cast<size_t>(kNtFakeOpenFile)]
+                           ->opcodes[tc3 - 1]
+                           .GetID());
 
   // Test the policy evaluation.
 
diff --git a/sandbox/win/src/policy_target.cc b/sandbox/win/src/policy_target.cc
index e79b51370ac2820cd7c40baf8c5b0bc4e8219d7f..d7bd48bbb25c5c01cb5c826cc2dbb86d98836856 100644
--- a/sandbox/win/src/policy_target.cc
+++ b/sandbox/win/src/policy_target.cc
@@ -2,12 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/policy_target.h"
 
 #include <ntstatus.h>
 #include <stddef.h>
 
-#include "base/compiler_specific.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/ipc_tags.h"
 #include "sandbox/win/src/policy_engine_processor.h"
@@ -40,17 +44,16 @@ bool QueryBroker(IpcTag ipc_id, CountedParameterSetBase* params) {
   PolicyGlobal* global_policy =
       reinterpret_cast<PolicyGlobal*>(g_shared_policy_memory);
 
-  if (!UNSAFE_TODO(global_policy->entry[static_cast<size_t>(ipc_id)])) {
+  if (!global_policy->entry[static_cast<size_t>(ipc_id)])
     return false;
-  }
 
   PolicyBuffer* policy = reinterpret_cast<PolicyBuffer*>(
-      UNSAFE_TODO(reinterpret_cast<char*>(g_shared_policy_memory) +
-                  reinterpret_cast<size_t>(
-                      global_policy->entry[static_cast<size_t>(ipc_id)])));
+      reinterpret_cast<char*>(g_shared_policy_memory) +
+      reinterpret_cast<size_t>(
+          global_policy->entry[static_cast<size_t>(ipc_id)]));
 
   if ((reinterpret_cast<size_t>(
-           UNSAFE_TODO(global_policy->entry[static_cast<size_t>(ipc_id)])) >
+           global_policy->entry[static_cast<size_t>(ipc_id)]) >
        global_policy->data_size) ||
       (g_shared_policy_size < global_policy->data_size)) {
     NOTREACHED_NT();
@@ -58,7 +61,7 @@ bool QueryBroker(IpcTag ipc_id, CountedParameterSetBase* params) {
   }
 
   for (size_t i = 0; i < params->count; i++) {
-    if (!UNSAFE_TODO(params->parameters[i]).IsValid()) {
+    if (!params->parameters[i].IsValid()) {
       NOTREACHED_NT();
       return false;
     }
diff --git a/sandbox/win/src/process_mitigations_deathtest.cc b/sandbox/win/src/process_mitigations_deathtest.cc
index eb91b95d98cb167daf32fc5a439f7592e1c9c4cf..4af304cb1609941f0df30d464276dd006ba25488 100644
--- a/sandbox/win/src/process_mitigations_deathtest.cc
+++ b/sandbox/win/src/process_mitigations_deathtest.cc
@@ -2,10 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/compiler_specific.h"
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
+#include "sandbox/win/src/process_mitigations.h"
+
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/string_number_conversions_win.h"
-#include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/tests/common/controller.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -29,7 +34,7 @@ SBOX_TESTS_COMMAND int CheckDeath(int argc, wchar_t** argv) {
 
   for (int i = 0; i < argc; i++) {
     int test;
-    if (!base::StringToInt(UNSAFE_TODO(argv[i]), &test)) {
+    if (!base::StringToInt(argv[i], &test)) {
       return SBOX_TEST_INVALID_PARAMETER;
     }
 
diff --git a/sandbox/win/src/process_mitigations_dyncode_unittest.cc b/sandbox/win/src/process_mitigations_dyncode_unittest.cc
index ab6a7ea8520bc6e50ba9781529d093a14d3ecdbe..eaedb5d2c80359f80bae83e34d113e33b6e1a283 100644
--- a/sandbox/win/src/process_mitigations_dyncode_unittest.cc
+++ b/sandbox/win/src/process_mitigations_dyncode_unittest.cc
@@ -2,11 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include <windows.h>
 
 #include <string>
 
-#include "base/compiler_specific.h"
 #include "base/files/file_util.h"
 #include "base/files/scoped_temp_dir.h"
 #include "base/memory/raw_ptr.h"
@@ -364,7 +368,7 @@ SBOX_TESTS_COMMAND int TestWin81DynamicCode(int argc, wchar_t** argv) {
   // [OPTIONAL] Arg2
   wchar_t* path = nullptr;
   if (argc > 1)
-    path = UNSAFE_TODO(argv[1]);
+    path = argv[1];
 
   return DynamicCodeTest(static_cast<DynCodeAPI>(test), path);
 }
@@ -376,25 +380,23 @@ SBOX_TESTS_COMMAND int TestWin81DynamicCode(int argc, wchar_t** argv) {
 // - [OPTIONAL] If Arg2 is MAPVIEWFILE, Arg3 is a file path to map.
 SBOX_TESTS_COMMAND int TestWin10DynamicCodeWithOptOut(int argc,
                                                       wchar_t** argv) {
-  if (argc < 2 || !argv[0] || !UNSAFE_TODO(argv[1])) {
+  if (argc < 2 || !argv[0] || !argv[1])
     return SBOX_TEST_INVALID_PARAMETER;
-  }
 
   // Arg1
   bool opt_out = false;
-  if (UNSAFE_TODO(::wcsicmp(argv[0], L"true")) == 0) {
+  if (::wcsicmp(argv[0], L"true") == 0)
     opt_out = true;
-  }
 
   // Arg2
-  int test = ::_wtoi(UNSAFE_TODO(argv[1]));
+  int test = ::_wtoi(argv[1]);
   if (test <= 0 || test >= NOTSUPPORTED)
     return SBOX_TEST_INVALID_PARAMETER;
 
   // [OPTIONAL] Arg3
   wchar_t* path = nullptr;
   if (argc > 2)
-    path = UNSAFE_TODO(argv[2]);
+    path = argv[2];
 
   // Spawn new thread and wait for it to finish!
   DynamicCodeOptOutThread opt_out_thread(opt_out, static_cast<DynCodeAPI>(test),
diff --git a/sandbox/win/src/process_mitigations_unittest.cc b/sandbox/win/src/process_mitigations_unittest.cc
index da27817ea7956117f41c27709c496b3da46c0a23..9e24fde5b347834b118ac037adc9990c058d2d63 100644
--- a/sandbox/win/src/process_mitigations_unittest.cc
+++ b/sandbox/win/src/process_mitigations_unittest.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/process_mitigations.h"
 
 #include <windows.h>
@@ -10,7 +15,6 @@
 #include <ktmw32.h>
 #include <ntstatus.h>
 
-#include "base/compiler_specific.h"
 #include "base/files/file.h"
 #include "base/numerics/safe_conversions.h"
 #include "base/path_service.h"
@@ -532,8 +536,7 @@ SBOX_TESTS_COMMAND int CheckWin10FontLoad(int argc, wchar_t** argv) {
     return SBOX_TEST_NOT_FOUND;
   font_data.resize(len);
 
-  int read =
-      UNSAFE_TODO(file.Read(0, &font_data[0], base::checked_cast<int>(len)));
+  int read = file.Read(0, &font_data[0], base::checked_cast<int>(len));
   file.Close();
 
   if (read != len)
@@ -571,13 +574,13 @@ SBOX_TESTS_COMMAND int TestChildProcess(int argc, wchar_t** argv) {
     return SBOX_TEST_INVALID_PARAMETER;
 
   bool process_finishes = true;
-  std::wstring arg2 = UNSAFE_TODO(argv[1]);
+  std::wstring arg2 = argv[1];
   if (arg2.compare(L"false") == 0)
     process_finishes = false;
 
   int desired_exit_code = 0;
   if (argc == 3) {
-    desired_exit_code = UNSAFE_TODO(wcstoul(argv[2], nullptr, 0));
+    desired_exit_code = wcstoul(argv[2], nullptr, 0);
   }
 
   std::wstring cmd = argv[0];
diff --git a/sandbox/win/src/restricted_token_test.cc b/sandbox/win/src/restricted_token_test.cc
index 62d8d641ba3114d605ded88602c2b9602d2fff00..41be74643654fac484b066292d5fc75053b32af2 100644
--- a/sandbox/win/src/restricted_token_test.cc
+++ b/sandbox/win/src/restricted_token_test.cc
@@ -2,14 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 // Integration tests for restricted tokens.
 
 #include <stddef.h>
-
-#include <optional>
 #include <string>
 
-#include "base/compiler_specific.h"
+#include <optional>
 #include "base/strings/stringprintf.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/win/access_token.h"
@@ -121,7 +124,7 @@ SBOX_TESTS_COMMAND int RestrictedTokenTest_openprocess(int argc,
   DWORD pid = _wtoi(argv[0]);
   if (pid == 0)
     return SBOX_TEST_NOT_FOUND;
-  DWORD desired_access = UNSAFE_TODO(wcstoul(argv[1], nullptr, 0));
+  DWORD desired_access = wcstoul(argv[1], nullptr, 0);
   base::win::ScopedHandle process_handle(
       ::OpenProcess(desired_access, false, pid));
   if (process_handle.is_valid()) {
@@ -136,7 +139,7 @@ SBOX_TESTS_COMMAND int RestrictedTokenTest_currentprocess_dup(int argc,
                                                               wchar_t** argv) {
   if (argc < 1)
     return SBOX_TEST_NOT_FOUND;
-  DWORD desired_access = UNSAFE_TODO(wcstoul(argv[0], nullptr, 0));
+  DWORD desired_access = wcstoul(argv[0], nullptr, 0);
 
   HANDLE dup_handle;
   if (!::DuplicateHandle(::GetCurrentProcess(), ::GetCurrentProcess(),
diff --git a/sandbox/win/src/sandbox_nt_util.h b/sandbox/win/src/sandbox_nt_util.h
index 55bae72d172dacff209c59468ea60b4758c808a2..fea61a7a8280c6529653e92093c2477a3a8088b7 100644
--- a/sandbox/win/src/sandbox_nt_util.h
+++ b/sandbox/win/src/sandbox_nt_util.h
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #ifndef SANDBOX_WIN_SRC_SANDBOX_NT_UTIL_H_
 #define SANDBOX_WIN_SRC_SANDBOX_NT_UTIL_H_
 
@@ -13,7 +18,6 @@
 #include <optional>
 #include <string_view>
 
-#include "base/compiler_specific.h"
 #include "base/containers/span.h"
 #include "base/memory/raw_ptr_exclusion.h"
 #include "sandbox/win/src/nt_internals.h"
@@ -224,7 +228,7 @@ CLIENT_ID GetCurrentClientId();
 __forceinline void Memset(void* ptr, int value, size_t num_bytes) {
   unsigned char* byte_ptr = static_cast<unsigned char*>(ptr);
   while (num_bytes--) {
-    *UNSAFE_TODO(byte_ptr++) = static_cast<unsigned char>(value);
+    *byte_ptr++ = static_cast<unsigned char>(value);
   }
 }
 
diff --git a/sandbox/win/src/sandbox_policy_diagnostic.cc b/sandbox/win/src/sandbox_policy_diagnostic.cc
index ebae0fb3e31bbfd37afe496665997690e87153cb..d2001394a7bd0e8290f36d0ac0db0523121fedb5 100644
--- a/sandbox/win/src/sandbox_policy_diagnostic.cc
+++ b/sandbox/win/src/sandbox_policy_diagnostic.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/sandbox_policy_diagnostic.h"
 
 #include <windows.h>
@@ -16,7 +21,6 @@
 #include <vector>
 
 #include "base/check.h"
-#include "base/compiler_specific.h"
 #include "base/json/json_writer.h"
 #include "base/numerics/safe_conversions.h"
 #include "base/strings/string_util.h"
@@ -299,16 +303,15 @@ base::Value::List GetPolicyOpcodes(const PolicyGlobal* policy_rules,
                                    IpcTag service) {
   base::Value::List entry;
   PolicyBuffer* policy_buffer =
-      UNSAFE_TODO(policy_rules->entry[static_cast<size_t>(service)]);
+      policy_rules->entry[static_cast<size_t>(service)];
   // Build up rules and emit when we hit an action.
   std::string cur_rule;
   for (size_t i = 0; i < policy_buffer->opcode_count; i++) {
-    const PolicyOpcode* opcode = &UNSAFE_TODO(policy_buffer->opcodes[i]);
+    const PolicyOpcode* opcode = &policy_buffer->opcodes[i];
     if (opcode->GetID() != OP_ACTION) {
       DCHECK(i + 1 < policy_buffer->opcode_count)
           << "Non-actions should not terminate rules";
-      bool peak =
-          UNSAFE_TODO(policy_buffer->opcodes[i + 1]).GetID() != OP_ACTION;
+      bool peak = policy_buffer->opcodes[i + 1].GetID() != OP_ACTION;
       cur_rule += GetPolicyOpcode(opcode, peak);
     } else {
       cur_rule += " -> ";
@@ -326,8 +329,7 @@ base::Value::Dict GetPolicyRules(const std::vector<IpcTag>& ipcs,
   base::Value::Dict results;
 
   for (auto ipc : ipcs) {
-    if (policy_rules &&
-        UNSAFE_TODO(policy_rules->entry[static_cast<size_t>(ipc)])) {
+    if (policy_rules && policy_rules->entry[static_cast<size_t>(ipc)]) {
       results.Set(GetIpcTagAsString(ipc), GetPolicyOpcodes(policy_rules, ipc));
     } else {
       results.Set(GetIpcTagAsString(ipc), base::Value::List());
@@ -405,16 +407,16 @@ PolicyDiagnostic::PolicyDiagnostic(PolicyBase* policy) {
     size_t policy_mem_size = original_rules->data_size + sizeof(PolicyGlobal);
     policy_rules_.reset(
         static_cast<sandbox::PolicyGlobal*>(::operator new(policy_mem_size)));
-    UNSAFE_TODO(memcpy(policy_rules_.get(), original_rules, policy_mem_size));
+    memcpy(policy_rules_.get(), original_rules, policy_mem_size);
     // Fixup pointers (see |PolicyGlobal| in policy_low_level.h).
     PolicyBuffer** original_entries = original_rules->entry;
     PolicyBuffer** copy_base = policy_rules_->entry;
     for (size_t i = 0; i < kSandboxIpcCount; i++) {
-      if (UNSAFE_TODO(policy_rules_->entry[i])) {
-        UNSAFE_TODO(policy_rules_->entry[i]) = reinterpret_cast<PolicyBuffer*>(
-            UNSAFE_TODO(reinterpret_cast<char*>(copy_base) +
-                        (reinterpret_cast<char*>(original_entries[i]) -
-                         reinterpret_cast<char*>(original_entries))));
+      if (policy_rules_->entry[i]) {
+        policy_rules_->entry[i] = reinterpret_cast<PolicyBuffer*>(
+            reinterpret_cast<char*>(copy_base) +
+            (reinterpret_cast<char*>(original_entries[i]) -
+             reinterpret_cast<char*>(original_entries)));
       }
     }
   }
diff --git a/sandbox/win/src/sharedmem_ipc_client.cc b/sandbox/win/src/sharedmem_ipc_client.cc
index 3228194cfcb7a05379ed67161ca26d301a8d447f..e41ab2fa8d080adde361e137c30071f0ee03e711 100644
--- a/sandbox/win/src/sharedmem_ipc_client.cc
+++ b/sandbox/win/src/sharedmem_ipc_client.cc
@@ -2,13 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/sharedmem_ipc_client.h"
 
 #include <stddef.h>
 #include <string.h>
 
 #include "base/check_op.h"
-#include "base/compiler_specific.h"
 #include "sandbox/win/src/crosscall_client.h"
 #include "sandbox/win/src/crosscall_params.h"
 #include "sandbox/win/src/sandbox.h"
@@ -53,8 +57,8 @@ void* SharedMemIPCClient::GetBuffer() {
   if (failure) {
     return nullptr;
   }
-  return UNSAFE_TODO(reinterpret_cast<char*>(control_) +
-                     control_->channels[ix].channel_base);
+  return reinterpret_cast<char*>(control_) +
+         control_->channels[ix].channel_base;
 }
 
 // If we need to cancel an IPC before issuing DoCall
@@ -63,8 +67,7 @@ void* SharedMemIPCClient::GetBuffer() {
 void SharedMemIPCClient::FreeBuffer(void* buffer) {
   size_t num = ChannelIndexFromBuffer(buffer);
   ChannelControl* channel = control_->channels;
-  LONG result =
-      ::InterlockedExchange(&UNSAFE_TODO(channel[num]).state, kFreeChannel);
+  LONG result = ::InterlockedExchange(&channel[num].state, kFreeChannel);
   DCHECK_NE(kFreeChannel, static_cast<ChannelState>(result));
 }
 
@@ -73,8 +76,8 @@ void SharedMemIPCClient::FreeBuffer(void* buffer) {
 // and should be constructed per call.
 SharedMemIPCClient::SharedMemIPCClient(void* shared_mem)
     : control_(reinterpret_cast<IPCControl*>(shared_mem)) {
-  first_base_ = UNSAFE_TODO(reinterpret_cast<char*>(shared_mem) +
-                            control_->channels[0].channel_base);
+  first_base_ =
+      reinterpret_cast<char*>(shared_mem) + control_->channels[0].channel_base;
   // There must be at least one channel.
   DCHECK(0 != control_->channels_count);
 }
@@ -92,7 +95,7 @@ ResultCode SharedMemIPCClient::DoCall(CrossCallParams* params,
   // Note that the IPC tag goes outside the buffer as well inside
   // the buffer. This should enable the server to prioritize based on
   // IPC tags without having to de-serialize the entire message.
-  UNSAFE_TODO(channel[num]).ipc_tag = params->GetTag();
+  channel[num].ipc_tag = params->GetTag();
 
   // Wait for the server to service this IPC call. After kIPCWaitTimeOut1
   // we check if the server_alive mutex was abandoned which will indicate
@@ -100,9 +103,8 @@ ResultCode SharedMemIPCClient::DoCall(CrossCallParams* params,
 
   // While the atomic signaling and waiting is not a requirement, it
   // is nice because we save a trip to kernel.
-  DWORD wait = SignalObjectAndWaitWrapper(UNSAFE_TODO(channel[num]).ping_event,
-                                          UNSAFE_TODO(channel[num]).pong_event,
-                                          kIPCWaitTimeOut1);
+  DWORD wait = SignalObjectAndWaitWrapper(
+      channel[num].ping_event, channel[num].pong_event, kIPCWaitTimeOut1);
   if (WAIT_TIMEOUT == wait) {
     // The server is taking too long. Enter a loop were we check if the
     // server_alive mutex has been abandoned which would signal a server crash
@@ -111,7 +113,7 @@ ResultCode SharedMemIPCClient::DoCall(CrossCallParams* params,
       wait = WaitForSingleObjectWrapper(control_->server_alive, 0);
       if (WAIT_TIMEOUT == wait) {
         // Server seems still alive. We already signaled so here we just wait.
-        wait = WaitForSingleObjectWrapper(UNSAFE_TODO(channel[num]).pong_event,
+        wait = WaitForSingleObjectWrapper(channel[num].pong_event,
                                           kIPCWaitTimeOut1);
         if (WAIT_OBJECT_0 == wait) {
           // The server took a long time but responded.
@@ -124,8 +126,7 @@ ResultCode SharedMemIPCClient::DoCall(CrossCallParams* params,
       } else {
         // The server has crashed and windows has signaled the mutex as
         // abandoned.
-        ::InterlockedExchange(&UNSAFE_TODO(channel[num]).state,
-                              kAbandonedChannel);
+        ::InterlockedExchange(&channel[num].state, kAbandonedChannel);
         control_->server_alive = 0;
         return SBOX_ERROR_CHANNEL_ERROR;
       }
@@ -157,9 +158,8 @@ size_t SharedMemIPCClient::LockFreeChannel(bool* severe_failure) {
   ChannelControl* channel = control_->channels;
   do {
     for (size_t ix = 0; ix != control_->channels_count; ++ix) {
-      if (kFreeChannel ==
-          ::InterlockedCompareExchange(&UNSAFE_TODO(channel[ix]).state,
-                                       kBusyChannel, kFreeChannel)) {
+      if (kFreeChannel == ::InterlockedCompareExchange(
+                              &channel[ix].state, kBusyChannel, kFreeChannel)) {
         *severe_failure = false;
         return ix;
       }
diff --git a/sandbox/win/src/sharedmem_ipc_server.cc b/sandbox/win/src/sharedmem_ipc_server.cc
index 423aa37e17ce320c6ba8e0c639ffbbdfd38b8396..c00fca65d42d8e42b5ddc8b9a697d0451e6f0c4c 100644
--- a/sandbox/win/src/sharedmem_ipc_server.cc
+++ b/sandbox/win/src/sharedmem_ipc_server.cc
@@ -2,13 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/sharedmem_ipc_server.h"
 
 #include <stddef.h>
 #include <stdint.h>
 
 #include "base/check.h"
-#include "base/compiler_specific.h"
 #include "base/functional/callback.h"
 #include "base/memory/ptr_util.h"
 #include "base/notreached.h"
@@ -101,8 +105,7 @@ bool SharedMemIPCServer::Init(void* shared_mem,
   // 4) initialize the server side of the channel (service_context).
   // 5) call the thread provider RegisterWait to register the ping events.
   for (size_t ix = 0; ix != channel_count; ++ix) {
-    ChannelControl* client_context =
-        &UNSAFE_TODO(client_control_->channels[ix]);
+    ChannelControl* client_context = &client_control_->channels[ix];
     ServerControl* service_context = new ServerControl;
     server_contexts_.push_back(base::WrapUnique(service_context));
 
@@ -122,8 +125,8 @@ bool SharedMemIPCServer::Init(void* shared_mem,
     service_context->shared_base = reinterpret_cast<char*>(shared_mem);
     service_context->channel_size = channel_size;
     service_context->channel = client_context;
-    service_context->channel_buffer = UNSAFE_TODO(service_context->shared_base +
-                                                  client_context->channel_base);
+    service_context->channel_buffer =
+        service_context->shared_base + client_context->channel_base;
     service_context->dispatcher = call_dispatcher_;
     service_context->target_info.process = target_process_;
     service_context->target_info.process_id = target_process_id_;
@@ -274,13 +277,12 @@ bool SharedMemIPCServer::InvokeCallback(const ServerControl* service_context,
     if (handler)
       SetCallError(SBOX_ERROR_FAILED_IPC, call_result);
   } else {
-    UNSAFE_TODO(
-        memcpy(call_result, &ipc_info.return_info, sizeof(*call_result)));
+    memcpy(call_result, &ipc_info.return_info, sizeof(*call_result));
     SetCallSuccess(call_result);
     if (params->IsInOut()) {
       // Maybe the params got changed by the broker. We need to upadte the
       // memory section.
-      UNSAFE_TODO(memcpy(ipc_buffer, params.get(), output_size));
+      memcpy(ipc_buffer, params.get(), output_size);
     }
   }
 
@@ -318,8 +320,7 @@ void __stdcall SharedMemIPCServer::ThreadPingEventReady(void* context,
   // Copy the answer back into the channel and signal the pong event. This
   // should wake up the client so it can finish the ipc cycle.
   CrossCallParams* call_params = reinterpret_cast<CrossCallParams*>(buffer);
-  UNSAFE_TODO(
-      memcpy(call_params->GetCallReturn(), &call_result, sizeof(call_result)));
+  memcpy(call_params->GetCallReturn(), &call_result, sizeof(call_result));
   ::InterlockedExchange(&service_context->channel->state, kAckChannel);
   ::SetEvent(service_context->pong_event.get());
 }
diff --git a/sandbox/win/src/target_interceptions.cc b/sandbox/win/src/target_interceptions.cc
index 89fba3e04ba409b1d77a63c0e7c2be4160d4d669..bcc56636e5d09ed9a912e92da452dff9a7ee19d5 100644
--- a/sandbox/win/src/target_interceptions.cc
+++ b/sandbox/win/src/target_interceptions.cc
@@ -2,11 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/target_interceptions.h"
 
 #include <ntstatus.h>
 
-#include "base/compiler_specific.h"
 #include "base/win/static_constants.h"
 #include "sandbox/win/src/interception_agent.h"
 #include "sandbox/win/src/sandbox_factory.h"
@@ -55,9 +59,9 @@ TargetNtMapViewOfSection(NtMapViewOfSectionFunction orig_MapViewOfSection,
       // find what looks like a valid export directory for a PE module but the
       // pointer to the module name will be pointing to invalid memory.
       __try {
-        if (ansi_module_name && (UNSAFE_TODO(GetNtExports()->_strnicmp)(
-                                     ansi_module_name, KERNEL32_DLL_NAME,
-                                     sizeof(KERNEL32_DLL_NAME)) == 0)) {
+        if (ansi_module_name &&
+            (GetNtExports()->_strnicmp(ansi_module_name, KERNEL32_DLL_NAME,
+                                       sizeof(KERNEL32_DLL_NAME)) == 0)) {
           s_state = kAfterKernel32;
         }
       } __except (EXCEPTION_EXECUTE_HANDLER) {
diff --git a/sandbox/win/src/top_level_dispatcher.cc b/sandbox/win/src/top_level_dispatcher.cc
index fd8da61900660edeb1a700a01dc878fe26c46999..b1db56e0436d8142ad3eff59bd82574b91370732 100644
--- a/sandbox/win/src/top_level_dispatcher.cc
+++ b/sandbox/win/src/top_level_dispatcher.cc
@@ -2,13 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/top_level_dispatcher.h"
 
 #include <stdint.h>
 #include <string.h>
 
 #include "base/check.h"
-#include "base/compiler_specific.h"
 #include "base/notreached.h"
 #include "sandbox/win/src/crosscall_server.h"
 #include "sandbox/win/src/filesystem_dispatcher.h"
@@ -24,7 +28,7 @@ namespace sandbox {
 
 TopLevelDispatcher::TopLevelDispatcher(PolicyBase* policy) : policy_(policy) {
   // Initialize the IPC dispatcher array.
-  UNSAFE_TODO(memset(ipc_targets_, 0, sizeof(ipc_targets_)));
+  memset(ipc_targets_, 0, sizeof(ipc_targets_));
 
   ConfigBase* config = policy_->config();
   CHECK(config->IsConfigured());
@@ -37,8 +41,7 @@ TopLevelDispatcher::TopLevelDispatcher(PolicyBase* policy) : policy_(policy) {
         filesystem_dispatcher_ =
             std::make_unique<FilesystemDispatcher>(policy_);
       }
-      UNSAFE_TODO(ipc_targets_[static_cast<size_t>(service)]) =
-          filesystem_dispatcher_.get();
+      ipc_targets_[static_cast<size_t>(service)] = filesystem_dispatcher_.get();
     }
   }
 
@@ -49,7 +52,7 @@ TopLevelDispatcher::TopLevelDispatcher(PolicyBase* policy) : policy_(policy) {
         thread_process_dispatcher_ =
             std::make_unique<ThreadProcessDispatcher>();
       }
-      UNSAFE_TODO(ipc_targets_[static_cast<size_t>(service)]) =
+      ipc_targets_[static_cast<size_t>(service)] =
           thread_process_dispatcher_.get();
     }
   }
@@ -64,7 +67,7 @@ TopLevelDispatcher::TopLevelDispatcher(PolicyBase* policy) : policy_(policy) {
       }
       // Technically we don't need to register for IPCs but we do need this
       // here to write the intercepts in SetupService.
-      UNSAFE_TODO(ipc_targets_[static_cast<size_t>(service)]) =
+      ipc_targets_[static_cast<size_t>(service)] =
           process_mitigations_win32k_dispatcher_.get();
     }
   }
@@ -81,7 +84,7 @@ TopLevelDispatcher::~TopLevelDispatcher() {}
 std::vector<IpcTag> TopLevelDispatcher::ipc_targets() {
   std::vector<IpcTag> results = {IpcTag::PING1, IpcTag::PING2};
   for (size_t ipc = 0; ipc < kSandboxIpcCount; ipc++) {
-    if (UNSAFE_TODO(ipc_targets_[ipc])) {
+    if (ipc_targets_[ipc]) {
       results.push_back(static_cast<IpcTag>(ipc));
     }
   }
@@ -155,7 +158,7 @@ Dispatcher* TopLevelDispatcher::GetDispatcher(IpcTag ipc_tag) {
     return nullptr;
   }
 
-  return UNSAFE_TODO(ipc_targets_[static_cast<size_t>(ipc_tag)]);
+  return ipc_targets_[static_cast<size_t>(ipc_tag)];
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/src/unload_dll_test.cc b/sandbox/win/src/unload_dll_test.cc
index 9ea364a469a2e73a885ae2b2127086a8bd0cb65e..3fa080b77da03ba074ac966444bb1327d29c2ba7 100644
--- a/sandbox/win/src/unload_dll_test.cc
+++ b/sandbox/win/src/unload_dll_test.cc
@@ -2,7 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/compiler_specific.h"
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "base/win/scoped_handle.h"
 #include "build/build_config.h"
 #include "sandbox/win/src/sandbox.h"
@@ -22,12 +26,12 @@ SBOX_TESTS_COMMAND int UseOneDLL(int argc, wchar_t** argv) {
 
   wchar_t option = (argv[0])[0];
   if ((option == L'L') || (option == L'B')) {
-    HMODULE module1 = ::LoadLibraryW(UNSAFE_TODO(argv[1]));
+    HMODULE module1 = ::LoadLibraryW(argv[1]);
     rv = (!module1) ? SBOX_TEST_FAILED : SBOX_TEST_SUCCEEDED;
   }
 
   if ((option == L'U') || (option == L'B')) {
-    HMODULE module2 = ::GetModuleHandleW(UNSAFE_TODO(argv[1]));
+    HMODULE module2 = ::GetModuleHandleW(argv[1]);
     rv = ::FreeLibrary(module2) ? SBOX_TEST_SUCCEEDED : SBOX_TEST_FAILED;
   }
   return rv;
diff --git a/sandbox/win/src/win_utils.cc b/sandbox/win/src/win_utils.cc
index 0f30bccaa2a82fc79fb9ac034bc9d3a072e7d618..7c5923ca58a6d2eea58ff6419a9b89f97b33b034 100644
--- a/sandbox/win/src/win_utils.cc
+++ b/sandbox/win/src/win_utils.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/src/win_utils.h"
 
 #include <windows.h>
@@ -18,7 +23,6 @@
 #include <vector>
 
 #include "base/check.h"
-#include "base/compiler_specific.h"
 #include "base/containers/span.h"
 #include "base/numerics/safe_math.h"
 #include "base/strings/string_util.h"
@@ -111,7 +115,7 @@ std::optional<std::wstring> GetPathFromHandle(HANDLE handle) {
   if (!buffer)
     return std::nullopt;
   OBJECT_NAME_INFORMATION* name =
-      UNSAFE_TODO(reinterpret_cast<OBJECT_NAME_INFORMATION*>(buffer->data()));
+      reinterpret_cast<OBJECT_NAME_INFORMATION*>(buffer->data());
   return std::wstring(
       name->ObjectName.Buffer,
       name->ObjectName.Length / sizeof(name->ObjectName.Buffer[0]));
@@ -124,7 +128,7 @@ std::optional<std::wstring> GetTypeNameFromHandle(HANDLE handle) {
   if (!buffer)
     return std::nullopt;
   OBJECT_TYPE_INFORMATION* name =
-      UNSAFE_TODO(reinterpret_cast<OBJECT_TYPE_INFORMATION*>(buffer->data()));
+      reinterpret_cast<OBJECT_TYPE_INFORMATION*>(buffer->data());
   return std::wstring(name->Name.Buffer,
                       name->Name.Length / sizeof(name->Name.Buffer[0]));
 }
diff --git a/sandbox/win/tests/common/controller.cc b/sandbox/win/tests/common/controller.cc
index 955a05dd8c4a141ff30f345cea8c330befb32239..08a70379ac2a70be8b22c5832c84db3f94c9be9c 100644
--- a/sandbox/win/tests/common/controller.cc
+++ b/sandbox/win/tests/common/controller.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/tests/common/controller.h"
 
 #include <memory>
@@ -9,7 +14,6 @@
 #include <string_view>
 
 #include "base/check.h"
-#include "base/compiler_specific.h"
 #include "base/functional/callback.h"
 #include "base/memory/platform_shared_memory_region.h"
 #include "base/memory/read_only_shared_memory_region.h"
@@ -422,21 +426,20 @@ int DispatchCall(int argc, wchar_t **argv) {
     return SBOX_TEST_INVALID_PARAMETER;
 
   // We hard code two tests to avoid dispatch failures.
-  if (0 == _wcsicmp(UNSAFE_TODO(argv[3]), L"wait")) {
-    Sleep(INFINITE);
-    return SBOX_TEST_TIMED_OUT;
+  if (0 == _wcsicmp(argv[3], L"wait")) {
+      Sleep(INFINITE);
+      return SBOX_TEST_TIMED_OUT;
   }
 
-  if (0 == _wcsicmp(UNSAFE_TODO(argv[3]), L"ping")) {
-    return SBOX_TEST_PING_OK;
-  }
+  if (0 == _wcsicmp(argv[3], L"ping"))
+      return SBOX_TEST_PING_OK;
 
   // If the caller shared a shared memory handle with us attempt to open it
   // in read only mode and sleep infinitely if we succeed.
-  if (0 == _wcsicmp(UNSAFE_TODO(argv[3]), L"shared_memory_handle")) {
+  if (0 == _wcsicmp(argv[3], L"shared_memory_handle")) {
     HANDLE raw_handle = nullptr;
     std::string_view test_contents = "Hello World";
-    base::StringToUint(base::AsStringPiece16(UNSAFE_TODO(argv[4])),
+    base::StringToUint(base::AsStringPiece16(argv[4]),
                        reinterpret_cast<unsigned int*>(&raw_handle));
     if (raw_handle == nullptr)
       return SBOX_TEST_INVALID_PARAMETER;
@@ -468,8 +471,7 @@ int DispatchCall(int argc, wchar_t **argv) {
     return SBOX_TEST_TIMED_OUT;
   }
 
-  SboxTestsState state =
-      static_cast<SboxTestsState>(_wtoi(UNSAFE_TODO(argv[2])));
+  SboxTestsState state = static_cast<SboxTestsState>(_wtoi(argv[2]));
   if ((state <= MIN_STATE) || (state >= MAX_STATE))
     return SBOX_TEST_INVALID_PARAMETER;
 
@@ -479,17 +481,16 @@ int DispatchCall(int argc, wchar_t **argv) {
                          reinterpret_cast<wchar_t*>(&DispatchCall), &module))
     return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
 
-  std::string command_name =
-      base::SysWideToMultiByte(UNSAFE_TODO(argv[3]), CP_UTF8);
+  std::string command_name = base::SysWideToMultiByte(argv[3], CP_UTF8);
   CommandFunction command = reinterpret_cast<CommandFunction>(
                                 ::GetProcAddress(module, command_name.c_str()));
   if (!command)
     return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
 
   if (BEFORE_INIT == state)
-    return command(argc - 4, UNSAFE_TODO(argv + 4));
+    return command(argc - 4, argv + 4);
   else if (EVERY_STATE == state)
-    command(argc - 4, UNSAFE_TODO(argv + 4));
+    command(argc - 4, argv + 4);
 
   TargetServices* target = SandboxFactory::GetTargetServices();
   if (target) {
@@ -497,9 +498,9 @@ int DispatchCall(int argc, wchar_t **argv) {
       return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
 
     if (BEFORE_REVERT == state)
-      return command(argc - 4, UNSAFE_TODO(argv + 4));
+      return command(argc - 4, argv + 4);
     else if (EVERY_STATE == state)
-      command(argc - 4, UNSAFE_TODO(argv + 4));
+      command(argc - 4, argv + 4);
 
 #if defined(ADDRESS_SANITIZER) || CHECK_WILL_STREAM()
     // Bind and leak dbghelp.dll before the token is lowered, otherwise some
@@ -511,11 +512,11 @@ int DispatchCall(int argc, wchar_t **argv) {
 #endif
 
     target->LowerToken();
-  } else if (0 != _wcsicmp(UNSAFE_TODO(argv[1]), L"-child-no-sandbox")) {
+  } else if (0 != _wcsicmp(argv[1], L"-child-no-sandbox")) {
     return SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
   }
 
-  return command(argc - 4, UNSAFE_TODO(argv + 4));
+  return command(argc - 4, argv + 4);
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/tests/integration_tests/integration_tests.cc b/sandbox/win/tests/integration_tests/integration_tests.cc
index 1bb9545b5c32983c920102a86356f6b16798eeed..9995eeba2371b51037aea7b79f95d88854062a0d 100644
--- a/sandbox/win/tests/integration_tests/integration_tests.cc
+++ b/sandbox/win/tests/integration_tests/integration_tests.cc
@@ -2,7 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/compiler_specific.h"
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "base/functional/bind.h"
 #include "base/test/launcher/unit_test_launcher.h"
 #include "base/test/test_suite.h"
@@ -23,8 +27,8 @@ DWORD SboxTestEventTimeout() {
 
 int wmain(int argc, wchar_t **argv) {
   if (argc >= 2) {
-    if (0 == _wcsicmp(UNSAFE_TODO(argv[1]), L"-child") ||
-        0 == _wcsicmp(UNSAFE_TODO(argv[1]), L"-child-no-sandbox")) {
+    if (0 == _wcsicmp(argv[1], L"-child") ||
+        0 == _wcsicmp(argv[1], L"-child-no-sandbox")) {
       // This inits the current commandline from GetCommandLineW().
       base::CommandLine::Init(0, nullptr);
       // This sets default timeouts.
diff --git a/sandbox/win/tests/integration_tests/integration_tests_test.cc b/sandbox/win/tests/integration_tests/integration_tests_test.cc
index b3dce99f4b448f4cf7089451b2c3c4487285e003..6ebed6c149840560fe4b6b0a47638cd15793b764 100644
--- a/sandbox/win/tests/integration_tests/integration_tests_test.cc
+++ b/sandbox/win/tests/integration_tests/integration_tests_test.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 // Some tests for the framework itself.
 
 #include <windows.h>
@@ -9,7 +14,6 @@
 #include <stddef.h>
 #include <stdlib.h>
 
-#include "base/compiler_specific.h"
 #include "base/debug/alias.h"
 #include "base/memory/raw_ptr.h"
 #include "base/strings/stringprintf.h"
@@ -107,9 +111,8 @@ SBOX_TESTS_COMMAND int IntegrationTestsTest_stuck(int argc, wchar_t **argv) {
 SBOX_TESTS_COMMAND int IntegrationTestsTest_args(int argc, wchar_t **argv) {
   for (int i = 0; i < argc; i++) {
     wchar_t argument[20];
-    size_t argument_bytes = wcslen(UNSAFE_TODO(argv[i])) * sizeof(wchar_t);
-    UNSAFE_TODO(
-        memcpy(argument, argv[i], __min(sizeof(argument), argument_bytes)));
+    size_t argument_bytes = wcslen(argv[i]) * sizeof(wchar_t);
+    memcpy(argument, argv[i], __min(sizeof(argument), argument_bytes));
   }
 
   return argc;
@@ -122,13 +125,13 @@ SBOX_TESTS_COMMAND int IntegrationTestsTest_event(int argc, wchar_t** argv) {
     return SBOX_TEST_INVALID_PARAMETER;
 
   base::win::ScopedHandle handle_started(
-      reinterpret_cast<HANDLE>(UNSAFE_TODO(wcstoul(argv[0], nullptr, 16))));
+      reinterpret_cast<HANDLE>(wcstoul(argv[0], nullptr, 16)));
   if (!handle_started.is_valid()) {
     return SBOX_TEST_NOT_FOUND;
   }
 
   base::win::ScopedHandle handle_done(
-      reinterpret_cast<HANDLE>(UNSAFE_TODO(wcstoul(argv[1], nullptr, 16))));
+      reinterpret_cast<HANDLE>(wcstoul(argv[1], nullptr, 16)));
   if (!handle_done.is_valid()) {
     return SBOX_TEST_NOT_FOUND;
   }
@@ -151,7 +154,7 @@ SBOX_TESTS_COMMAND int IntegrationTestsTest_memory(int argc, wchar_t** argv) {
   }
 
   base::win::ScopedHandle handle_started(
-      reinterpret_cast<HANDLE>(UNSAFE_TODO(wcstoul(argv[0], nullptr, 16))));
+      reinterpret_cast<HANDLE>(wcstoul(argv[0], nullptr, 16)));
   if (!handle_started.is_valid()) {
     return SBOX_TEST_NOT_FOUND;
   }
diff --git a/sandbox/win/tests/unit_tests/unit_tests.cc b/sandbox/win/tests/unit_tests/unit_tests.cc
index c5537240479947ece01d993264898cb744f94b4a..0250339aa4e8e7e3c97eccf22fa31ca1de132f16 100644
--- a/sandbox/win/tests/unit_tests/unit_tests.cc
+++ b/sandbox/win/tests/unit_tests/unit_tests.cc
@@ -2,7 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/compiler_specific.h"
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "base/functional/bind.h"
 #include "base/test/launcher/unit_test_launcher.h"
 #include "base/test/test_suite.h"
@@ -10,10 +14,9 @@
 
 int wmain(int argc, wchar_t **argv) {
   if (argc >= 2) {
-    if (0 == _wcsicmp(UNSAFE_TODO(argv[1]), L"-child")) {
+    if (0 == _wcsicmp(argv[1], L"-child"))
       // This instance is a child, not the test.
       return 0;
-    }
   }
 
   base::TestSuite test_suite(argc, argv);
diff --git a/sandbox/win/tests/validation_tests/commands.cc b/sandbox/win/tests/validation_tests/commands.cc
index ee661743acc95f4d3bdcad16fc17787db5022848..7c6813f482b4b2b4637524ca30d255d7292aea89 100644
--- a/sandbox/win/tests/validation_tests/commands.cc
+++ b/sandbox/win/tests/validation_tests/commands.cc
@@ -2,6 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "sandbox/win/tests/validation_tests/commands.h"
 
 #include <windows.h>
@@ -11,7 +16,6 @@
 
 #include <string>
 
-#include "base/compiler_specific.h"
 #include "sandbox/win/src/sandbox_factory.h"
 #include "sandbox/win/src/target_services.h"
 #include "sandbox/win/tests/common/controller.h"
@@ -86,9 +90,9 @@ int TestValidWindow(HWND window) {
 }
 
 SBOX_TESTS_COMMAND int OpenProcessCmd(int argc, wchar_t **argv) {
-  return (argc == 2)
-             ? TestOpenProcess(_wtol(argv[0]), _wtol(UNSAFE_TODO(argv[1])))
-             : SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
+  return (argc == 2) ?
+      TestOpenProcess(_wtol(argv[0]), _wtol(argv[1])) :
+      SBOX_TEST_FAILED_TO_EXECUTE_COMMAND;
 }
 
 int TestOpenProcess(DWORD process_id, DWORD access_mask) {
@@ -157,7 +161,7 @@ SBOX_TESTS_COMMAND int OpenKey(int argc, wchar_t **argv) {
   // Get the subkey.
   std::wstring subkey;
   if (argc == 2) {
-    subkey = UNSAFE_TODO(argv[1]);
+    subkey = argv[1];
     trim_quote(&subkey);
   }
 
diff --git a/sandbox/win/tests/validation_tests/unit_tests.cc b/sandbox/win/tests/validation_tests/unit_tests.cc
index 491cfc55d250bc918a82025c673612ab033a0b67..3f05656b1e759f5921a0811eb8793f69548b4979 100644
--- a/sandbox/win/tests/validation_tests/unit_tests.cc
+++ b/sandbox/win/tests/validation_tests/unit_tests.cc
@@ -2,7 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "base/compiler_specific.h"
+#ifdef UNSAFE_BUFFERS_BUILD
+// TODO(crbug.com/351564777): Remove this and convert code to safer constructs.
+#pragma allow_unsafe_buffers
+#endif
+
 #include "base/functional/bind.h"
 #include "base/test/launcher/unit_test_launcher.h"
 #include "base/test/test_suite.h"
@@ -11,9 +15,8 @@
 
 int wmain(int argc, wchar_t **argv) {
   if (argc >= 2) {
-    if (0 == _wcsicmp(UNSAFE_TODO(argv[1]), L"-child")) {
+    if (0 == _wcsicmp(argv[1], L"-child"))
       return sandbox::DispatchCall(argc, argv);
-    }
   }
 
   // Force binary unduplication for crbug.com/959223.
