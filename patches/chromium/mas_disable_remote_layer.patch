From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Cheng Zhao <zcbenz@gmail.com>
Date: Thu, 20 Sep 2018 17:48:49 -0700
Subject: mas: disable remote layer APIs (CAContext and CALayerHost) for MAS
 build

Accordin to ccameron:

For apps that spend a lot of time watching video (especially fullscreen video),
the power/battery usage will likely increase 1.5x to 2x. For something that is,
e.g, scrolling, it'll be smaller, more like 1.15x or 1.25x.

In terms of performance, the impact will likely be fairly small -- any app that
could hit 60fps before will likely still be able to hit 60fps. There may even be
cases where performance improves when disabling remote CoreAnimation (remote
CoreAnimation is really only about battery usage).

diff --git a/gpu/ipc/service/image_transport_surface_overlay_mac.h b/gpu/ipc/service/image_transport_surface_overlay_mac.h
<<<<<<< HEAD
index 54df9cd23be7441f9b61e9f94b191b3a6a7ab6fd..861f6579d9fb93ab7c3741fd39eaaf8bda76ed9d 100644
||||||| parent of 273e49d57a (chore: update galactus)
index 54df9cd23be7441f9b61e9f94b191b3a6a7ab6fd..1ba6c4804cd98c6aa118fcd4ee74b1368648bde6 100644
=======
index 9666bbab1fc8e046e2702aef9e78028252e984ed..641672ad8db8e845225a057ba26ced49288e4635 100644
>>>>>>> 273e49d57a (chore: update galactus)
--- a/gpu/ipc/service/image_transport_surface_overlay_mac.h
+++ b/gpu/ipc/service/image_transport_surface_overlay_mac.h
@@ -18,7 +18,9 @@
 #include "ui/gl/gl_surface_egl.h"
 #include "ui/gl/gpu_switching_observer.h"
 
+#if !IS_MAS_BUILD()
 @class CAContext;
+#endif
 @class CALayer;
 
 namespace ui {
@@ -117,7 +119,9 @@ class ImageTransportSurfaceOverlayMac : public gl::GLSurface,
   base::WeakPtr<ImageTransportSurfaceDelegate> delegate_;
 
   bool use_remote_layer_api_;
+#if !IS_MAS_BUILD()
   base::scoped_nsobject<CAContext> ca_context_;
+#endif
   std::unique_ptr<ui::CALayerTreeCoordinator> ca_layer_tree_coordinator_;
 
   gfx::Size pixel_size_;
@@ -212,7 +216,9 @@ class ImageTransportSurfaceOverlayMacEGL : public gl::GLSurfaceEGL,
   base::WeakPtr<ImageTransportSurfaceDelegate> delegate_;
 
   bool use_remote_layer_api_;
+#if !IS_MAS_BUILD()
   base::scoped_nsobject<CAContext> ca_context_;
+#endif
   std::unique_ptr<ui::CALayerTreeCoordinator> ca_layer_tree_coordinator_;
 
   gfx::Size pixel_size_;
diff --git a/gpu/ipc/service/image_transport_surface_overlay_mac.mm b/gpu/ipc/service/image_transport_surface_overlay_mac.mm
index 02d9a854feb178544a95c932f02566c31823f165..349a6abae36aadb5ebdbc48dc319e0603d79364e 100644
--- a/gpu/ipc/service/image_transport_surface_overlay_mac.mm
+++ b/gpu/ipc/service/image_transport_surface_overlay_mac.mm
@@ -69,6 +69,7 @@
   ca_layer_tree_coordinator_ = std::make_unique<ui::CALayerTreeCoordinator>(
       use_remote_layer_api_, allow_av_sample_buffer_display_layer);
 
+#if !IS_MAS_BUILD()
   // Create the CAContext to send this to the GPU process, and the layer for
   // the context.
   if (use_remote_layer_api_) {
@@ -76,6 +77,7 @@
                                                    options:@{}] retain]);
     [ca_context_ setLayer:ca_layer_tree_coordinator_->GetCALayerForDisplay()];
   }
+#endif
 }
 
 ImageTransportSurfaceOverlayMac::~ImageTransportSurfaceOverlayMac() {
@@ -153,7 +155,9 @@
                          "GLImpl", static_cast<int>(gl::GetGLImplementation()),
                          "width", pixel_size_.width());
     if (use_remote_layer_api_) {
+#if !IS_MAS_BUILD()
       params.ca_context_id = [ca_context_ contextId];
+#endif
     } else {
       IOSurfaceRef io_surface =
           ca_layer_tree_coordinator_->GetIOSurfaceForDisplay();
@@ -385,6 +389,7 @@
   ca_layer_tree_coordinator_ = std::make_unique<ui::CALayerTreeCoordinator>(
       use_remote_layer_api_, allow_av_sample_buffer_display_layer);
 
+#if !IS_MAS_BUILD()
   // Create the CAContext to send this to the GPU process, and the layer for
   // the context.
   if (use_remote_layer_api_) {
@@ -393,6 +398,7 @@
                                                    options:@{}] retain]);
     [ca_context_ setLayer:ca_layer_tree_coordinator_->GetCALayerForDisplay()];
   }
+#endif
 }
 
 ImageTransportSurfaceOverlayMacEGL::~ImageTransportSurfaceOverlayMacEGL() {
@@ -174,7 +176,9 @@
                          "GLImpl", static_cast<int>(gl::GetGLImplementation()),
                          "width", pixel_size_.width());
     if (use_remote_layer_api_) {
+#if !IS_MAS_BUILD()
       params.ca_context_id = [ca_context_ contextId];
+#endif
     } else {
       IOSurfaceRef io_surface =
           ca_layer_tree_coordinator_->GetIOSurfaceForDisplay();
diff --git a/ui/accelerated_widget_mac/display_ca_layer_tree.mm b/ui/accelerated_widget_mac/display_ca_layer_tree.mm
index 2c4821b34f71d30ce814bd1f3cf9a7a76bbaac66..c7dc371c780a405f502a84c77e92251ae08f66e0 100644
--- a/ui/accelerated_widget_mac/display_ca_layer_tree.mm
+++ b/ui/accelerated_widget_mac/display_ca_layer_tree.mm
@@ -99,6 +99,7 @@ - (void)setContentsChanged;
 }
 
 void DisplayCALayerTree::GotCALayerFrame(uint32_t ca_context_id) {
+#if !IS_MAS_BUILD()
   // Early-out if the remote layer has not changed.
   if ([remote_layer_ contextId] == ca_context_id)
     return;
@@ -123,6 +124,9 @@ - (void)setContentsChanged;
     [io_surface_layer_ removeFromSuperlayer];
     io_surface_layer_.reset();
   }
+#else
+  NOTREACHED() << "Remote layer is being used in MAS build";
+#endif
 }
 
 void DisplayCALayerTree::GotIOSurfaceFrame(
diff --git a/ui/base/cocoa/remote_layer_api.h b/ui/base/cocoa/remote_layer_api.h
index 9b691e2f16c68235dd180a28b6eb2eefc91f8e4c..9d4a7fb36e671980024b895eaafab2d970ac2818 100644
--- a/ui/base/cocoa/remote_layer_api.h
+++ b/ui/base/cocoa/remote_layer_api.h
@@ -13,6 +13,7 @@
 
 #include "base/component_export.h"
 
+#if !IS_MAS_BUILD()
 // The CGSConnectionID is used to create the CAContext in the process that is
 // going to share the CALayers that it is rendering to another process to
 // display.
@@ -50,6 +51,8 @@ typedef uint32_t CAContextID;
 
 #endif // __OBJC__
 
+#endif // MAS_BUILD
+
 namespace ui {
 
 // This function will check if all of the interfaces listed above are supported
diff --git a/ui/base/cocoa/remote_layer_api.mm b/ui/base/cocoa/remote_layer_api.mm
index e23eb7719a9798afe984c6af6a422167b93d89b5..d448bc09ee54fc77f1ed4d088d1369b96f83a1db 100644
--- a/ui/base/cocoa/remote_layer_api.mm
+++ b/ui/base/cocoa/remote_layer_api.mm
@@ -10,6 +10,7 @@
 
 namespace ui {
 
+#if !IS_MAS_BUILD()
 namespace {
 // Control use of cross-process CALayers to display content directly from the
 // GPU process on Mac.
@@ -17,8 +18,10 @@
              "RemoteCoreAnimationAPI",
              base::FEATURE_ENABLED_BY_DEFAULT);
 }  // namespace
+#endif
 
 bool RemoteLayerAPISupported() {
+#if !IS_MAS_BUILD()
   if (!base::FeatureList::IsEnabled(kRemoteCoreAnimationAPI))
     return false;
 
@@ -50,6 +53,9 @@ bool RemoteLayerAPISupported() {
 
   // If everything is there, we should be able to use the API.
   return true;
+#else
+  return false;
+#endif  // MAS_BUILD
 }
 
 }  // namespace
