diff --git a/content/renderer/browser_plugin/browser_plugin.cc b/content/renderer/browser_plugin/browser_plugin.cc
index d64895137a73..c42dd6ddf172 100644
--- a/content/renderer/browser_plugin/browser_plugin.cc
+++ b/content/renderer/browser_plugin/browser_plugin.cc
@@ -642,15 +642,11 @@ blink::WebInputEventResult BrowserPlugin::HandleInputEvent(
 
   DCHECK(!blink::WebInputEvent::IsTouchEventType(event.GetType()));
 
-  // With direct event routing turned on, BrowserPlugin should almost never
-  // see wheel events any more. The two exceptions are (1) scroll bubbling, and
-  // (2) synthetic mouse wheels generated by touchpad GesturePinch events on
-  // Mac, which always go to the mainframe and thus may hit BrowserPlugin if
-  // it's in a top-level embedder. In both cases we should indicate the event
-  // as not handled (for GesturePinch on Mac, indicating the event has been
-  // handled leads to touchpad pinch not working).
-  if (event.GetType() == blink::WebInputEvent::kMouseWheel)
-    return blink::WebInputEventResult::kNotHandled;
+  if (event.GetType() == blink::WebInputEvent::kMouseWheel) {
+    auto wheel_event = static_cast<const blink::WebMouseWheelEvent&>(event);
+    if (wheel_event.resending_plugin_id == browser_plugin_instance_id_)
+      return blink::WebInputEventResult::kNotHandled;
+  }
 
   if (blink::WebInputEvent::IsGestureEventType(event.GetType())) {
     auto gesture_event = static_cast<const blink::WebGestureEvent&>(event);
